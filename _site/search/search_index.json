{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Gearpump is a real-time big data streaming engine. It is inspired by recent advances in the Akka framework and a desire to improve on existing streaming frameworks. Gearpump is event/message based and featured as low latency handling, high performance, exactly once semantics, dynamic topology update, Apache Storm compatibility, etc. The name Gearpump is a reference to the engineering term \"gear pump,\" which is a super simple pump that consists of only two gears, but is very powerful at streaming water. Gearpump Technical Highlights Gearpump's feature set includes: Extremely high performance Low latency Configurable message delivery guarantee (at least once, exactly once). Highly extensible Dynamic DAG Storm compatibility Samoa compatibility Both high level and low level API Gearpump Performance Per initial benchmarks we are able to process 18 million messages/second (100 bytes per message) with a 8ms latency on a 4-node cluster.","title":"Overview"},{"location":"index.html#gearpump-technical-highlights","text":"Gearpump's feature set includes: Extremely high performance Low latency Configurable message delivery guarantee (at least once, exactly once). Highly extensible Dynamic DAG Storm compatibility Samoa compatibility Both high level and low level API","title":"Gearpump Technical Highlights"},{"location":"index.html#gearpump-performance","text":"Per initial benchmarks we are able to process 18 million messages/second (100 bytes per message) with a 8ms latency on a 4-node cluster.","title":"Gearpump Performance"},{"location":"api/java.html","text":"Placeholder","title":"Java API"},{"location":"api/scala.html","text":"Placeholder","title":"Scala API"},{"location":"deployment/deployment-configuration.html","text":"Master and Worker configuration Master and Worker daemons will only read configuration from conf/gear.conf . Master reads configuration from section master and gearpump: master { } gearpump{ } Worker reads configuration from section worker and gearpump: worker { } gearpump{ } Configuration for user submitted application job For user application job, it will read configuration file gear.conf and application.conf from classpath, while application.conf has higher priority. The default classpath contains: conf/ current working directory. For example, you can put a application.conf on your working directory, and then it will be effective when you submit a new job application. Logging To change the log level, you need to change both gear.conf , and log4j.properties . To change the log level for master and worker daemon Please change log4j.rootLevel in log4j.properties , gearpump-master.akka.loglevel and gearpump-worker.akka.loglevel in gear.conf . To change the log level for application job Please change log4j.rootLevel in log4j.properties , and akka.loglevel in gear.conf or application.conf . Gearpump Default Configuration This is the default configuration for gear.conf . config item default value description gearpump.hostname \"127.0.0.1\" hostname of current machine. If you are using local mode, then set this to 127.0.0.1. If you are using cluster mode, make sure this hostname can be accessed by other machines. gearpump.cluster.masters [\"127.0.0.1:3000\"] Config to set the master nodes of the cluster. If there are multiple master in the list, then the master nodes runs in HA mode. For example, you may start three master, on node1: bin/master -ip node1 -port 3000 , on node2: bin/master -ip node2 -port 3000 , on node3: bin/master -ip node3 -port 3000 , then you need to set gearpump.cluster.masters = [\"node1:3000\",\"node2:3000\",\"node3:3000\"] gearpump.task-dispatcher \"gearpump.shared-thread-pool-dispatcher\" default dispatcher for task actor gearpump.metrics.enabled true flag to enable the metrics system gearpump.metrics.sample-rate 1 We will take one sample every gearpump.metrics.sample-rate data points. Note it may have impact that the statistics on UI portal is not accurate. Change it to 1 if you want accurate metrics in UI gearpump.metrics.report-interval-ms 15000 we will report once every 15 seconds gearpump.metrics.reporter \"akka\" available value: \"graphite\", \"akka\", \"logfile\" which write the metrics data to different places. gearpump.retainHistoryData.hours 72 max hours of history data to retain, Note: Due to implementation limitation(we store all history in memory), please don't set this to too big which may exhaust memory. gearpump.retainHistoryData.intervalMs 3600000 time interval between two data points for history data (unit: ms). Usually this is set to a big value so that we only store coarse-grain data gearpump.retainRecentData.seconds 300 max seconds of recent data to retain. This is for the fine-grain data gearpump.retainRecentData.intervalMs 15000 time interval between two data points for recent data (unit: ms) gearpump.log.daemon.dir \"logs\" The log directory for daemon processes(relative to current working directory) gearpump.log.application.dir \"logs\" The log directory for applications(relative to current working directory) gearpump.serializers a map custom serializer for streaming application, e.g. \"scala.Array\" = \"\" gearpump.worker.slots 1000 How many slots each worker contains gearpump.appmaster.vmargs \"-server -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3 -Djava.rmi.server.hostname=localhost\" JVM arguments for AppMaster gearpump.appmaster.extraClasspath \"\" JVM default class path for AppMaster gearpump.executor.vmargs \"-server -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3 -Djava.rmi.server.hostname=localhost\" JVM arguments for executor gearpump.executor.extraClasspath \"\" JVM default class path for executor gearpump.jarstore.rootpath \"jarstore/\" Define where the submitted jar file will be stored. This path follows the hadoop path schema. For HDFS, use hdfs://host:port/path/ , and HDFS HA, hdfs://namespace/path/ ; if you want to store on master nodes, then use local directory. jarstore.rootpath = \"jarstore/\" will point to relative directory where master is started. jarstore.rootpath = \"/jarstore/\" will point to absolute directory on master server gearpump.scheduling.scheduler-class \"io.gearpump.cluster.scheduler.PriorityScheduler\" Class to schedule the applications. gearpump.services.host \"127.0.0.1\" dashboard UI host address gearpump.services.port 8090 dashboard UI host port gearpump.netty.buffer-size 5242880 netty connection buffer size gearpump.netty.max-retries 30 maximum number of retries for a netty client to connect to remote host gearpump.netty.base-sleep-ms 100 base sleep time for a netty client to retry a connection. Actual sleep time is a multiple of this value gearpump.netty.max-sleep-ms 1000 maximum sleep time for a netty client to retry a connection gearpump.netty.message-batch-size 262144 netty max batch size gearpump.netty.flush-check-interval 10 max flush interval for the netty layer, in milliseconds gearpump.netty.dispatcher \"gearpump.shared-thread-pool-dispatcher\" default dispatcher for netty client and server gearpump.shared-thread-pool-dispatcher default Dispatcher with \"fork-join-executor\" default shared thread pool dispatcher gearpump.single-thread-dispatcher PinnedDispatcher default single thread dispatcher gearpump.serialization-framework \"io.gearpump.serializer.FastKryoSerializationFramework\" Gearpump has built-in serialization framework using Kryo. Users are allowed to use a different serialization framework, like Protobuf. See io.gearpump.serializer.FastKryoSerializationFramework to find how a custom serialization framework can be defined worker.executor-share-same-jvm-as-worker false whether the executor actor is started in the same jvm(process) from which running the worker actor, the intention of this setting is for the convenience of single machine debugging, however, the app jar need to be added to the worker's classpath when you set it true and have a 'real' worker in the cluster","title":"Configuration"},{"location":"deployment/deployment-configuration.html#master-and-worker-configuration","text":"Master and Worker daemons will only read configuration from conf/gear.conf . Master reads configuration from section master and gearpump: master { } gearpump{ } Worker reads configuration from section worker and gearpump: worker { } gearpump{ }","title":"Master and Worker configuration"},{"location":"deployment/deployment-configuration.html#configuration-for-user-submitted-application-job","text":"For user application job, it will read configuration file gear.conf and application.conf from classpath, while application.conf has higher priority. The default classpath contains: conf/ current working directory. For example, you can put a application.conf on your working directory, and then it will be effective when you submit a new job application.","title":"Configuration for user submitted application job"},{"location":"deployment/deployment-configuration.html#logging","text":"To change the log level, you need to change both gear.conf , and log4j.properties .","title":"Logging"},{"location":"deployment/deployment-configuration.html#to-change-the-log-level-for-master-and-worker-daemon","text":"Please change log4j.rootLevel in log4j.properties , gearpump-master.akka.loglevel and gearpump-worker.akka.loglevel in gear.conf .","title":"To change the log level for master and worker daemon"},{"location":"deployment/deployment-configuration.html#to-change-the-log-level-for-application-job","text":"Please change log4j.rootLevel in log4j.properties , and akka.loglevel in gear.conf or application.conf .","title":"To change the log level for application job"},{"location":"deployment/deployment-configuration.html#gearpump-default-configuration","text":"This is the default configuration for gear.conf . config item default value description gearpump.hostname \"127.0.0.1\" hostname of current machine. If you are using local mode, then set this to 127.0.0.1. If you are using cluster mode, make sure this hostname can be accessed by other machines. gearpump.cluster.masters [\"127.0.0.1:3000\"] Config to set the master nodes of the cluster. If there are multiple master in the list, then the master nodes runs in HA mode. For example, you may start three master, on node1: bin/master -ip node1 -port 3000 , on node2: bin/master -ip node2 -port 3000 , on node3: bin/master -ip node3 -port 3000 , then you need to set gearpump.cluster.masters = [\"node1:3000\",\"node2:3000\",\"node3:3000\"] gearpump.task-dispatcher \"gearpump.shared-thread-pool-dispatcher\" default dispatcher for task actor gearpump.metrics.enabled true flag to enable the metrics system gearpump.metrics.sample-rate 1 We will take one sample every gearpump.metrics.sample-rate data points. Note it may have impact that the statistics on UI portal is not accurate. Change it to 1 if you want accurate metrics in UI gearpump.metrics.report-interval-ms 15000 we will report once every 15 seconds gearpump.metrics.reporter \"akka\" available value: \"graphite\", \"akka\", \"logfile\" which write the metrics data to different places. gearpump.retainHistoryData.hours 72 max hours of history data to retain, Note: Due to implementation limitation(we store all history in memory), please don't set this to too big which may exhaust memory. gearpump.retainHistoryData.intervalMs 3600000 time interval between two data points for history data (unit: ms). Usually this is set to a big value so that we only store coarse-grain data gearpump.retainRecentData.seconds 300 max seconds of recent data to retain. This is for the fine-grain data gearpump.retainRecentData.intervalMs 15000 time interval between two data points for recent data (unit: ms) gearpump.log.daemon.dir \"logs\" The log directory for daemon processes(relative to current working directory) gearpump.log.application.dir \"logs\" The log directory for applications(relative to current working directory) gearpump.serializers a map custom serializer for streaming application, e.g. \"scala.Array\" = \"\" gearpump.worker.slots 1000 How many slots each worker contains gearpump.appmaster.vmargs \"-server -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3 -Djava.rmi.server.hostname=localhost\" JVM arguments for AppMaster gearpump.appmaster.extraClasspath \"\" JVM default class path for AppMaster gearpump.executor.vmargs \"-server -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3 -Djava.rmi.server.hostname=localhost\" JVM arguments for executor gearpump.executor.extraClasspath \"\" JVM default class path for executor gearpump.jarstore.rootpath \"jarstore/\" Define where the submitted jar file will be stored. This path follows the hadoop path schema. For HDFS, use hdfs://host:port/path/ , and HDFS HA, hdfs://namespace/path/ ; if you want to store on master nodes, then use local directory. jarstore.rootpath = \"jarstore/\" will point to relative directory where master is started. jarstore.rootpath = \"/jarstore/\" will point to absolute directory on master server gearpump.scheduling.scheduler-class \"io.gearpump.cluster.scheduler.PriorityScheduler\" Class to schedule the applications. gearpump.services.host \"127.0.0.1\" dashboard UI host address gearpump.services.port 8090 dashboard UI host port gearpump.netty.buffer-size 5242880 netty connection buffer size gearpump.netty.max-retries 30 maximum number of retries for a netty client to connect to remote host gearpump.netty.base-sleep-ms 100 base sleep time for a netty client to retry a connection. Actual sleep time is a multiple of this value gearpump.netty.max-sleep-ms 1000 maximum sleep time for a netty client to retry a connection gearpump.netty.message-batch-size 262144 netty max batch size gearpump.netty.flush-check-interval 10 max flush interval for the netty layer, in milliseconds gearpump.netty.dispatcher \"gearpump.shared-thread-pool-dispatcher\" default dispatcher for netty client and server gearpump.shared-thread-pool-dispatcher default Dispatcher with \"fork-join-executor\" default shared thread pool dispatcher gearpump.single-thread-dispatcher PinnedDispatcher default single thread dispatcher gearpump.serialization-framework \"io.gearpump.serializer.FastKryoSerializationFramework\" Gearpump has built-in serialization framework using Kryo. Users are allowed to use a different serialization framework, like Protobuf. See io.gearpump.serializer.FastKryoSerializationFramework to find how a custom serialization framework can be defined worker.executor-share-same-jvm-as-worker false whether the executor actor is started in the same jvm(process) from which running the worker actor, the intention of this setting is for the convenience of single machine debugging, however, the app jar need to be added to the worker's classpath when you set it true and have a 'real' worker in the cluster","title":"Gearpump Default Configuration"},{"location":"deployment/deployment-docker.html","text":"Gearpump Docker Container There is pre-built docker container available at Docker Repo Check the documents there to find how to launch a Gearpump cluster in one line.","title":"Docker Mode"},{"location":"deployment/deployment-docker.html#gearpump-docker-container","text":"There is pre-built docker container available at Docker Repo Check the documents there to find how to launch a Gearpump cluster in one line.","title":"Gearpump Docker Container"},{"location":"deployment/deployment-ha.html","text":"To support HA, we allow to start master on multiple nodes. They will form a quorum to decide consistency. For example, if we start master on 5 nodes and 2 nodes are down, then the cluster is still consistent and functional. Here are the steps to enable the HA mode: 1. Configure. Select master machines Distribute the package to all nodes. Modify conf/gear.conf on all nodes. You MUST configure gearpump.hostname to make it point to your hostname(or ip), and gearpump.cluster.masters to a list of master nodes. For example, if I have 3 master nodes (node1, node2, and node3), then the gearpump.cluster.masters can be set as gearpump.cluster { masters = [\"node1:3000\", \"node2:3000\", \"node3:3000\"] } Configure distributed storage to store application jars. In conf/gear.conf , For entry gearpump.jarstore.rootpath , please choose the storage folder for application jars. You need to make sure this jar storage is highly available. We support two storage systems: 1). HDFS You need to configure the gearpump.jarstore.rootpath like this hdfs://host:port/path/ For HDFS HA, hdfs://namespace/path/ 2). Shared NFS folder First you need to map the NFS directory to local directory(same path) on all machines of master nodes. Then you need to set the gearpump.jarstore.rootpath like this: file:///your_nfs_mapping_directory 3). If you don't set this value, we will use the local directory of master node. NOTE! There is no HA guarantee in this case, which means we are unable to recover running applications when master goes down. 2. Start Daemon. On node1, node2, node3, Start Master ## on node1 bin/master -ip node1 -port 3000 ## on node2 bin/master -ip node2 -port 3000 ## on node3 bin/master -ip node3 -port 3000 3. Done! Now you have a highly available HA cluster. You can kill any node, the master HA will take effect. NOTE : It can take up to 15 seconds for master node to fail-over. You can change the fail-over timeout time by adding config in gear.conf gearpump-master.akka.cluster.auto-down-unreachable-after=10s or set it to a smaller value","title":"High Availability"},{"location":"deployment/deployment-ha.html#1-configure","text":"","title":"1. Configure."},{"location":"deployment/deployment-ha.html#select-master-machines","text":"Distribute the package to all nodes. Modify conf/gear.conf on all nodes. You MUST configure gearpump.hostname to make it point to your hostname(or ip), and gearpump.cluster.masters to a list of master nodes. For example, if I have 3 master nodes (node1, node2, and node3), then the gearpump.cluster.masters can be set as gearpump.cluster { masters = [\"node1:3000\", \"node2:3000\", \"node3:3000\"] }","title":"Select master machines"},{"location":"deployment/deployment-ha.html#configure-distributed-storage-to-store-application-jars","text":"In conf/gear.conf , For entry gearpump.jarstore.rootpath , please choose the storage folder for application jars. You need to make sure this jar storage is highly available. We support two storage systems: 1). HDFS You need to configure the gearpump.jarstore.rootpath like this hdfs://host:port/path/ For HDFS HA, hdfs://namespace/path/ 2). Shared NFS folder First you need to map the NFS directory to local directory(same path) on all machines of master nodes. Then you need to set the gearpump.jarstore.rootpath like this: file:///your_nfs_mapping_directory 3). If you don't set this value, we will use the local directory of master node. NOTE! There is no HA guarantee in this case, which means we are unable to recover running applications when master goes down.","title":"Configure distributed storage to store application jars."},{"location":"deployment/deployment-ha.html#2-start-daemon","text":"On node1, node2, node3, Start Master ## on node1 bin/master -ip node1 -port 3000 ## on node2 bin/master -ip node2 -port 3000 ## on node3 bin/master -ip node3 -port 3000","title":"2. Start Daemon."},{"location":"deployment/deployment-ha.html#3-done","text":"Now you have a highly available HA cluster. You can kill any node, the master HA will take effect. NOTE : It can take up to 15 seconds for master node to fail-over. You can change the fail-over timeout time by adding config in gear.conf gearpump-master.akka.cluster.auto-down-unreachable-after=10s or set it to a smaller value","title":"3. Done!"},{"location":"deployment/deployment-local.html","text":"You can start the Gearpump service in a single JVM(local mode), or in a distributed cluster(cluster mode). To start the cluster in local mode, you can use the local /local.bat helper scripts, it is very useful for developing or troubleshooting. Below are the steps to start a Gearpump service in Local mode: Step 1: Get your Gearpump binary ready To get your Gearpump service running in local mode, you first need to have a Gearpump distribution binary ready. Please follow this guide to have the binary. Step 2: Start the cluster You can start a local mode cluster in single line ## start the master and 2 workers in single JVM. The master will listen on 3000 ## you can Ctrl+C to kill the local cluster after you finished the startup tutorial. bin/local NOTE: You may need to execute chmod +x bin/* in shell to make the script file local executable. NOTE: You can change the default port by changing config gearpump.cluster.masters in conf/gear.conf . NOTE: Change the working directory . Log files by default will be generated under current working directory. So, please \"cd\" to required working directly before running the shell commands. NOTE: Run as Daemon . You can run it as a background process. For example, use nohup on Linux. Step 3: Start the Web UI server Open another shell, bin/services You can manage the applications in UI http://127.0.0.1:8090 or by Command Line tool . The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users.","title":"Local Mode"},{"location":"deployment/deployment-local.html#step-1-get-your-gearpump-binary-ready","text":"To get your Gearpump service running in local mode, you first need to have a Gearpump distribution binary ready. Please follow this guide to have the binary.","title":"Step 1: Get your Gearpump binary ready"},{"location":"deployment/deployment-local.html#step-2-start-the-cluster","text":"You can start a local mode cluster in single line ## start the master and 2 workers in single JVM. The master will listen on 3000 ## you can Ctrl+C to kill the local cluster after you finished the startup tutorial. bin/local NOTE: You may need to execute chmod +x bin/* in shell to make the script file local executable. NOTE: You can change the default port by changing config gearpump.cluster.masters in conf/gear.conf . NOTE: Change the working directory . Log files by default will be generated under current working directory. So, please \"cd\" to required working directly before running the shell commands. NOTE: Run as Daemon . You can run it as a background process. For example, use nohup on Linux.","title":"Step 2: Start the cluster"},{"location":"deployment/deployment-local.html#step-3-start-the-web-ui-server","text":"Open another shell, bin/services You can manage the applications in UI http://127.0.0.1:8090 or by Command Line tool . The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users.","title":"Step 3: Start the Web UI server"},{"location":"deployment/deployment-msg-delivery.html","text":"How to deploy for At Least Once Message Delivery? As introduced in the What is At Least Once Message Delivery , Gearpump has a built in KafkaSource. To get at least once message delivery, users should deploy a Kafka cluster as the offset store along with the Gearpump cluster. Here's an example to deploy a local Kafka cluster. download the latest Kafka from the official website and extract to a local directory ( $KAFKA_HOME ) Boot up the single-node Zookeeper instance packaged with Kafka. $KAFKA_HOME/bin/zookeeper-server-start.sh $KAFKA_HOME/config/zookeeper.properties Start a Kafka broker $KAFKA_HOME/bin/kafka-server-start.sh $KAFKA_HOME/config/kafka.properties When creating a offset store for KafkaSource , set the zookeeper connect string to localhost:2181 and broker list to localhost:9092 in KafkaStorageFactory . val offsetStorageFactory = new KafkaStorageFactory(\"localhost:2181\", \"localhost:9092\") val source = new KafkaSource(\"topic1\", \"localhost:2181\", offsetStorageFactory) How to deploy for Exactly Once Message Delivery? Exactly Once Message Delivery requires both an offset store and a checkpoint store. For the offset store, a Kafka cluster should be deployed as in the previous section. As for the checkpoint store, Gearpump has built-in support for Hadoop file systems, like HDFS. Hence, users should deploy a HDFS cluster alongside the Gearpump cluster. Here's an example to deploy a local HDFS cluster. download Hadoop 2.6 from the official website and extracts it to a local directory HADOOP_HOME add following configuration to $HADOOP_HOME/etc/core-site.xml <configuration> <property> <name>fs.defaultFS</name> <value>hdfs://localhost:9000</value> </property> </configuration> start HDFS $HADOOP_HOME/sbin/start-dfs.sh When creating a HadoopCheckpointStore , set the hadoop configuration as in the core-site.xml val hadoopConfig = new Configuration hadoopConfig.set(\"fs.defaultFS\", \"hdfs://localhost:9000\") val checkpointStoreFactory = new HadoopCheckpointStoreFactory(\"MessageCount\", hadoopConfig, new FileSizeRotation(1000))","title":"Reliable Message Delivery"},{"location":"deployment/deployment-msg-delivery.html#how-to-deploy-for-at-least-once-message-delivery","text":"As introduced in the What is At Least Once Message Delivery , Gearpump has a built in KafkaSource. To get at least once message delivery, users should deploy a Kafka cluster as the offset store along with the Gearpump cluster. Here's an example to deploy a local Kafka cluster. download the latest Kafka from the official website and extract to a local directory ( $KAFKA_HOME ) Boot up the single-node Zookeeper instance packaged with Kafka. $KAFKA_HOME/bin/zookeeper-server-start.sh $KAFKA_HOME/config/zookeeper.properties Start a Kafka broker $KAFKA_HOME/bin/kafka-server-start.sh $KAFKA_HOME/config/kafka.properties When creating a offset store for KafkaSource , set the zookeeper connect string to localhost:2181 and broker list to localhost:9092 in KafkaStorageFactory . val offsetStorageFactory = new KafkaStorageFactory(\"localhost:2181\", \"localhost:9092\") val source = new KafkaSource(\"topic1\", \"localhost:2181\", offsetStorageFactory)","title":"How to deploy for At Least Once Message Delivery?"},{"location":"deployment/deployment-msg-delivery.html#how-to-deploy-for-exactly-once-message-delivery","text":"Exactly Once Message Delivery requires both an offset store and a checkpoint store. For the offset store, a Kafka cluster should be deployed as in the previous section. As for the checkpoint store, Gearpump has built-in support for Hadoop file systems, like HDFS. Hence, users should deploy a HDFS cluster alongside the Gearpump cluster. Here's an example to deploy a local HDFS cluster. download Hadoop 2.6 from the official website and extracts it to a local directory HADOOP_HOME add following configuration to $HADOOP_HOME/etc/core-site.xml <configuration> <property> <name>fs.defaultFS</name> <value>hdfs://localhost:9000</value> </property> </configuration> start HDFS $HADOOP_HOME/sbin/start-dfs.sh When creating a HadoopCheckpointStore , set the hadoop configuration as in the core-site.xml val hadoopConfig = new Configuration hadoopConfig.set(\"fs.defaultFS\", \"hdfs://localhost:9000\") val checkpointStoreFactory = new HadoopCheckpointStoreFactory(\"MessageCount\", hadoopConfig, new FileSizeRotation(1000))","title":"How to deploy for Exactly Once Message Delivery?"},{"location":"deployment/deployment-resource-isolation.html","text":"CGroup (abbreviated from control groups) is a Linux kernel feature to limit, account, and isolate resource usage (CPU, memory, disk I/O, etc.) of process groups.In Gearpump, we use cgroup to manage CPU resources. Start CGroup Service CGroup feature is only supported by Linux whose kernel version is larger than 2.6.18. Please also make sure the SELinux is disabled before start CGroup. The following steps are supposed to be executed by root user. Check /etc/cgconfig.conf exist or not. If not exists, please yum install libcgroup . Run following command to see whether the cpu subsystem is already mounted to the file system. lssubsys -m Each subsystem in CGroup will have a corresponding mount file path in local file system. For example, the following output shows that cpu subsystem is mounted to file path /sys/fs/cgroup/cpu cpu /sys/fs/cgroup/cpu net_cls /sys/fs/cgroup/net_cls blkio /sys/fs/cgroup/blkio perf_event /sys/fs/cgroup/perf_event If you want to assign permission to user gear to launch Gearpump Worker and applications with resource isolation enabled, you need to check gear's uid and gid in /etc/passwd file, let's take 500 for example. Add following content to /etc/cgconfig.conf # The mount point of cpu subsystem. # If your system already mounted it, this segment should be eliminated. mount { cpu = /cgroup/cpu; } # Here the group name \"gearpump\" represents a node in CGroup's hierarchy tree. # When the CGroup service is started, there will be a folder generated under the mount point of cpu subsystem, # whose name is \"gearpump\". group gearpump { perm { task { uid = 500; gid = 500; } admin { uid = 500; gid = 500; } } cpu { } } Please note that if the output of step 2 shows that cpu subsystem is already mounted, then the mount segment should not be included. Then Start cgroup service sudo service cgconfig restart There should be a folder gearpump generated under the mount point of cpu subsystem and its owner is gear:gear . Repeat the above-mentioned steps on each machine where you want to launch Gearpump. Enable Cgroups in Gearpump Login into the machine which has CGroup prepared with user gear . ssh gear@node Enter into Gearpump's home folder, edit gear.conf under folder ${GEARPUMP_HOME}/conf/ gearpump.worker.executor-process-launcher = \"io.gearpump.cluster.worker.CGroupProcessLauncher\" gearpump.cgroup.root = \"gearpump\" Please note the gearpump.cgroup.root gearpump must be consistent with the group name in /etc/cgconfig.conf. Repeat the above-mentioned steps on each machine where you want to launch Gearpump Start the Gearpump cluster, please refer to Deploy Gearpump in Standalone Mode Launch Application From Command Line Login into the machine which has Gearpump distribution. Enter into Gearpump's home folder, edit gear.conf under folder ${GEARPUMP_HOME}/conf/ gearpump.cgroup.cpu-core-limit-per-executor = ${your_preferred_int_num} Here the configuration is the number of CPU cores per executor can use and -1 means no limitation Submit application bin/gear app -jar examples/sol-2.12-0.9.0-assembly.jar -streamProducer 10 -streamProcessor 10 Then you can run command top to monitor the cpu usage. Launch Application From Dashboard If you want to submit the application from dashboard, by default the gearpump.cgroup.cpu-core-limit-per-executor is inherited from Worker's configuration. You can provide your own conf file to override it. Limitations Windows and Mac OS X don't support CGroup, so the resource isolation will not work even if you turn it on. There will not be any limitation for single executor's cpu usage.","title":"Resource Isolation"},{"location":"deployment/deployment-resource-isolation.html#start-cgroup-service","text":"CGroup feature is only supported by Linux whose kernel version is larger than 2.6.18. Please also make sure the SELinux is disabled before start CGroup. The following steps are supposed to be executed by root user. Check /etc/cgconfig.conf exist or not. If not exists, please yum install libcgroup . Run following command to see whether the cpu subsystem is already mounted to the file system. lssubsys -m Each subsystem in CGroup will have a corresponding mount file path in local file system. For example, the following output shows that cpu subsystem is mounted to file path /sys/fs/cgroup/cpu cpu /sys/fs/cgroup/cpu net_cls /sys/fs/cgroup/net_cls blkio /sys/fs/cgroup/blkio perf_event /sys/fs/cgroup/perf_event If you want to assign permission to user gear to launch Gearpump Worker and applications with resource isolation enabled, you need to check gear's uid and gid in /etc/passwd file, let's take 500 for example. Add following content to /etc/cgconfig.conf # The mount point of cpu subsystem. # If your system already mounted it, this segment should be eliminated. mount { cpu = /cgroup/cpu; } # Here the group name \"gearpump\" represents a node in CGroup's hierarchy tree. # When the CGroup service is started, there will be a folder generated under the mount point of cpu subsystem, # whose name is \"gearpump\". group gearpump { perm { task { uid = 500; gid = 500; } admin { uid = 500; gid = 500; } } cpu { } } Please note that if the output of step 2 shows that cpu subsystem is already mounted, then the mount segment should not be included. Then Start cgroup service sudo service cgconfig restart There should be a folder gearpump generated under the mount point of cpu subsystem and its owner is gear:gear . Repeat the above-mentioned steps on each machine where you want to launch Gearpump.","title":"Start CGroup Service"},{"location":"deployment/deployment-resource-isolation.html#enable-cgroups-in-gearpump","text":"Login into the machine which has CGroup prepared with user gear . ssh gear@node Enter into Gearpump's home folder, edit gear.conf under folder ${GEARPUMP_HOME}/conf/ gearpump.worker.executor-process-launcher = \"io.gearpump.cluster.worker.CGroupProcessLauncher\" gearpump.cgroup.root = \"gearpump\" Please note the gearpump.cgroup.root gearpump must be consistent with the group name in /etc/cgconfig.conf. Repeat the above-mentioned steps on each machine where you want to launch Gearpump Start the Gearpump cluster, please refer to Deploy Gearpump in Standalone Mode","title":"Enable Cgroups in Gearpump"},{"location":"deployment/deployment-resource-isolation.html#launch-application-from-command-line","text":"Login into the machine which has Gearpump distribution. Enter into Gearpump's home folder, edit gear.conf under folder ${GEARPUMP_HOME}/conf/ gearpump.cgroup.cpu-core-limit-per-executor = ${your_preferred_int_num} Here the configuration is the number of CPU cores per executor can use and -1 means no limitation Submit application bin/gear app -jar examples/sol-2.12-0.9.0-assembly.jar -streamProducer 10 -streamProcessor 10 Then you can run command top to monitor the cpu usage.","title":"Launch Application From Command Line"},{"location":"deployment/deployment-resource-isolation.html#launch-application-from-dashboard","text":"If you want to submit the application from dashboard, by default the gearpump.cgroup.cpu-core-limit-per-executor is inherited from Worker's configuration. You can provide your own conf file to override it.","title":"Launch Application From Dashboard"},{"location":"deployment/deployment-resource-isolation.html#limitations","text":"Windows and Mac OS X don't support CGroup, so the resource isolation will not work even if you turn it on. There will not be any limitation for single executor's cpu usage.","title":"Limitations"},{"location":"deployment/deployment-security.html","text":"Until now Gearpump supports deployment in a secured Yarn cluster and writing to secured HBase, where \"secured\" means Kerberos enabled. Further security related feature is in progress. How to launch Gearpump in a secured Yarn cluster Suppose user gear will launch gearpump on YARN, then the corresponding principal gear should be created in KDC server. Create Kerberos principal for user gear , on the KDC machine sudo kadmin.local In the kadmin.local or kadmin shell, create the principal kadmin: addprinc gear/fully.qualified.domain.name@YOUR-REALM.COM Remember that user gear must exist on every node of Yarn. Upload the gearpump-2.12-0.9.0.zip to remote HDFS Folder, suggest to put it under /usr/lib/gearpump/gearpump-2.12-0.9.0.zip Create HDFS folder /user/gear/, make sure all read-write rights are granted for user gear drwxr-xr-x - gear gear 0 2015-11-27 14:03 /user/gear Put the YARN configurations under classpath. Before calling yarnclient launch , make sure you have put all yarn configuration files under classpath. Typically, you can just copy all files under $HADOOP_HOME/etc/hadoop from one of the YARN cluster machine to conf/yarnconf of gearpump. $HADOOP_HOME points to the Hadoop installation directory. Get Kerberos credentials to submit the job: kinit gearpump/fully.qualified.domain.name@YOUR-REALM.COM Here you can login with keytab or password. Please refer Kerberos's document for details. yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip How to write to secured HBase When the remote HBase is security enabled, a kerberos keytab and the corresponding principal name need to be provided for the gearpump-hbase connector. Specifically, the UserConfig object passed into the HBaseSink should contain {(\"gearpump.keytab.file\", \"\\\\$keytab\"), (\"gearpump.kerberos.principal\", \"\\\\$principal\")} . example code of writing to secured HBase: val principal = \"gearpump/fully.qualified.domain.name@YOUR-REALM.COM\" val keytabContent = Files.toByteArray(new File(\"path_to_keytab_file\")) val appConfig = UserConfig.empty .withString(\"gearpump.kerberos.principal\", principal) .withBytes(\"gearpump.keytab.file\", keytabContent) val sink = new HBaseSink(appConfig, \"$tableName\") val sinkProcessor = DataSinkProcessor(sink, \"$sinkNum\") val split = Processor[Split](\"$splitNum\") val computation = split ~> sinkProcessor val application = StreamApplication(\"HBase\", Graph(computation), UserConfig.empty) Note here the keytab file set into config should be a byte array. Future Plan More external components support HDFS Kafka Authentication(Kerberos) Since Gearpump\u2019s Master-Worker structure is similar to HDFS\u2019s NameNode-DataNode and Yarn\u2019s ResourceManager-NodeManager, we may follow the way they use. User creates kerberos principal and keytab for Gearpump. Deploy the keytab files to all the cluster nodes. Configure Gearpump\u2019s conf file, specify kerberos principal and local keytab file location. Start Master and Worker. Every application has a submitter/user. We will separate the application from different users, like different log folders for different applications. Only authenticated users can submit the application to Gearpump's Master. Authorization Hopefully more on this soon","title":"YARN Security Guide"},{"location":"deployment/deployment-security.html#how-to-launch-gearpump-in-a-secured-yarn-cluster","text":"Suppose user gear will launch gearpump on YARN, then the corresponding principal gear should be created in KDC server. Create Kerberos principal for user gear , on the KDC machine sudo kadmin.local In the kadmin.local or kadmin shell, create the principal kadmin: addprinc gear/fully.qualified.domain.name@YOUR-REALM.COM Remember that user gear must exist on every node of Yarn. Upload the gearpump-2.12-0.9.0.zip to remote HDFS Folder, suggest to put it under /usr/lib/gearpump/gearpump-2.12-0.9.0.zip Create HDFS folder /user/gear/, make sure all read-write rights are granted for user gear drwxr-xr-x - gear gear 0 2015-11-27 14:03 /user/gear Put the YARN configurations under classpath. Before calling yarnclient launch , make sure you have put all yarn configuration files under classpath. Typically, you can just copy all files under $HADOOP_HOME/etc/hadoop from one of the YARN cluster machine to conf/yarnconf of gearpump. $HADOOP_HOME points to the Hadoop installation directory. Get Kerberos credentials to submit the job: kinit gearpump/fully.qualified.domain.name@YOUR-REALM.COM Here you can login with keytab or password. Please refer Kerberos's document for details. yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip","title":"How to launch Gearpump in a secured Yarn cluster"},{"location":"deployment/deployment-security.html#how-to-write-to-secured-hbase","text":"When the remote HBase is security enabled, a kerberos keytab and the corresponding principal name need to be provided for the gearpump-hbase connector. Specifically, the UserConfig object passed into the HBaseSink should contain {(\"gearpump.keytab.file\", \"\\\\$keytab\"), (\"gearpump.kerberos.principal\", \"\\\\$principal\")} . example code of writing to secured HBase: val principal = \"gearpump/fully.qualified.domain.name@YOUR-REALM.COM\" val keytabContent = Files.toByteArray(new File(\"path_to_keytab_file\")) val appConfig = UserConfig.empty .withString(\"gearpump.kerberos.principal\", principal) .withBytes(\"gearpump.keytab.file\", keytabContent) val sink = new HBaseSink(appConfig, \"$tableName\") val sinkProcessor = DataSinkProcessor(sink, \"$sinkNum\") val split = Processor[Split](\"$splitNum\") val computation = split ~> sinkProcessor val application = StreamApplication(\"HBase\", Graph(computation), UserConfig.empty) Note here the keytab file set into config should be a byte array.","title":"How to write to secured HBase"},{"location":"deployment/deployment-security.html#future-plan","text":"","title":"Future Plan"},{"location":"deployment/deployment-security.html#more-external-components-support","text":"HDFS Kafka","title":"More external components support"},{"location":"deployment/deployment-security.html#authenticationkerberos","text":"Since Gearpump\u2019s Master-Worker structure is similar to HDFS\u2019s NameNode-DataNode and Yarn\u2019s ResourceManager-NodeManager, we may follow the way they use. User creates kerberos principal and keytab for Gearpump. Deploy the keytab files to all the cluster nodes. Configure Gearpump\u2019s conf file, specify kerberos principal and local keytab file location. Start Master and Worker. Every application has a submitter/user. We will separate the application from different users, like different log folders for different applications. Only authenticated users can submit the application to Gearpump's Master.","title":"Authentication(Kerberos)"},{"location":"deployment/deployment-security.html#authorization","text":"Hopefully more on this soon","title":"Authorization"},{"location":"deployment/deployment-standalone.html","text":"Standalone mode is a distributed cluster mode. That is, Gearpump runs as service without the help from other services (e.g. YARN). To deploy Gearpump in cluster mode, please first check that the Pre-requisites are met. How to Install You need to have Gearpump binary at hand. Please refer to How to get gearpump distribution to get the Gearpump binary. You are suggested to unzip the package to same directory path on every machine you planned to install Gearpump. To install Gearpump, you at least need to change the configuration in conf/gear.conf . Config Default value Description gearpump.hostname \"127.0.0.1\" Host or IP address of current machine. The ip/host need to be reachable from other machines in the cluster. gearpump.cluster.masters [\"127.0.0.1:3000\"] List of all master nodes, with each item represents host and port of one master. gearpump.worker.slots 1000 how many slots this worker has Besides this, there are other optional configurations related with logs, metrics, transports, ui. You can refer to Configuration Guide for more details. Start the Cluster Daemons in Standlone mode In Standalone mode, you can start master and worker in different JVMs. To start master: bin/master -ip xx -port xx The ip and port will be checked against settings under conf/gear.conf , so you need to make sure they are consistent. NOTE: You may need to execute chmod +x bin/* in shell to make the script file master executable. NOTE : for high availability, please check Master HA Guide To start worker: bin/worker Start UI bin/services After UI is started, you can browse to http://{web_ui_host}:8090 to view the cluster status. The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users. NOTE: The UI port can be configured in gear.conf . Check Configuration Guide for information. Bash tool to start cluster There is a bash tool bin/start-cluster.sh can launch the cluster conveniently. You need to change the file conf/masters , conf/workers and conf/dashboard to specify the corresponding machines. Before running the bash tool, please make sure the Gearpump package is already unzipped to the same directory path on every machine. bin/stop-cluster.sh is used to stop the whole cluster of course. The bash tool is able to launch the cluster without changing the conf/gear.conf on every machine. The bash sets the gearpump.cluster.masters and other configurations using JAVA_OPTS. However, please note when you log into any these unconfigured machine and try to launch the dashboard or submit the application, you still need to modify conf/gear.conf manually because the JAVA_OPTS is missing.","title":"Standalone Mode"},{"location":"deployment/deployment-standalone.html#how-to-install","text":"You need to have Gearpump binary at hand. Please refer to How to get gearpump distribution to get the Gearpump binary. You are suggested to unzip the package to same directory path on every machine you planned to install Gearpump. To install Gearpump, you at least need to change the configuration in conf/gear.conf . Config Default value Description gearpump.hostname \"127.0.0.1\" Host or IP address of current machine. The ip/host need to be reachable from other machines in the cluster. gearpump.cluster.masters [\"127.0.0.1:3000\"] List of all master nodes, with each item represents host and port of one master. gearpump.worker.slots 1000 how many slots this worker has Besides this, there are other optional configurations related with logs, metrics, transports, ui. You can refer to Configuration Guide for more details.","title":"How to Install"},{"location":"deployment/deployment-standalone.html#start-the-cluster-daemons-in-standlone-mode","text":"In Standalone mode, you can start master and worker in different JVMs.","title":"Start the Cluster Daemons in Standlone mode"},{"location":"deployment/deployment-standalone.html#to-start-master","text":"bin/master -ip xx -port xx The ip and port will be checked against settings under conf/gear.conf , so you need to make sure they are consistent. NOTE: You may need to execute chmod +x bin/* in shell to make the script file master executable. NOTE : for high availability, please check Master HA Guide","title":"To start master:"},{"location":"deployment/deployment-standalone.html#to-start-worker","text":"bin/worker","title":"To start worker:"},{"location":"deployment/deployment-standalone.html#start-ui","text":"bin/services After UI is started, you can browse to http://{web_ui_host}:8090 to view the cluster status. The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users. NOTE: The UI port can be configured in gear.conf . Check Configuration Guide for information.","title":"Start UI"},{"location":"deployment/deployment-standalone.html#bash-tool-to-start-cluster","text":"There is a bash tool bin/start-cluster.sh can launch the cluster conveniently. You need to change the file conf/masters , conf/workers and conf/dashboard to specify the corresponding machines. Before running the bash tool, please make sure the Gearpump package is already unzipped to the same directory path on every machine. bin/stop-cluster.sh is used to stop the whole cluster of course. The bash tool is able to launch the cluster without changing the conf/gear.conf on every machine. The bash sets the gearpump.cluster.masters and other configurations using JAVA_OPTS. However, please note when you log into any these unconfigured machine and try to launch the dashboard or submit the application, you still need to modify conf/gear.conf manually because the JAVA_OPTS is missing.","title":"Bash tool to start cluster"},{"location":"deployment/deployment-ui-authentication.html","text":"What is this about? How to enable UI authentication? Change config file gear.conf, find entry gearpump-ui.gearpump.ui-security.authentication-enabled , change the value to true gearpump-ui.gearpump.ui-security.authentication-enabled = true Restart the UI dashboard, and then the UI authentication is enabled. It will prompt for user name and password. How many authentication methods Gearpump UI server support? Currently, It supports: Username-Password based authentication and OAuth2 based authentication. User-Password based authentication is enabled when gearpump-ui.gearpump.ui-security.authentication-enabled , and CANNOT be disabled. UI server admin can also choose to enable auxiliary OAuth2 authentication channel. User-Password based authentication User-Password based authentication covers all authentication scenarios which requires user to enter an explicit username and password. Gearpump provides a built-in ConfigFileBasedAuthenticator which verify user name and password against password hashcode stored in config files. However, developer can choose to extends the io.gearpump.security.Authenticator to provide a custom User-Password based authenticator, to support LDAP, Kerberos, and Database-based authentication... ConfigFileBasedAuthenticator: built-in User-Password Authenticator ConfigFileBasedAuthenticator store all user name and password hashcode in configuration file gear.conf. Here is the steps to configure ConfigFileBasedAuthenticator. How to add or remove user? For the default authentication plugin, it has three categories of users: admins, users, and guests. admins: have unlimited permission, like shutdown a cluster, add/remove machines. users: have limited permission to submit an application and etc.. guests: can not submit/kill applications, but can view the application status. System administrator can add or remove user by updating config file conf/gear.conf . Suppose we want to add user jerry as an administrator, here are the steps: Pick a password, and generate the digest for this password. Suppose we use password ilovegearpump , to generate the digest: bin/gear io.gearpump.security.PasswordUtil -password ilovegearpump It will generate a digest value like this: CgGxGOxlU8ggNdOXejCeLxy+isrCv0TrS37HwA== Change config file conf/gear.conf at path gearpump-ui.gearpump.ui-security.config-file-based-authenticator.admins , add user jerry in this list: admins = { ## Default Admin. Username: admin, password: admin ## !!! Please replace this builtin account for production cluster for security reason. !!! \"admin\" = \"AeGxGOxlU8QENdOXejCeLxy+isrCv0TrS37HwA==\" \"jerry\" = \"CgGxGOxlU8ggNdOXejCeLxy+isrCv0TrS37HwA==\" } Restart the UI dashboard by bin/services to make the change effective. Group \"admins\" have very unlimited permission, you may want to restrict the permission. In that case you can modify gearpump-ui.gearpump.ui-security.config-file-based-authenticator.users or gearpump-ui.gearpump.ui-security.config-file-based-authenticator.guests . See description at conf/gear.conf to find more information. What is the default user and password? For ConfigFileBasedAuthenticator, Gearpump distribution is shipped with two default users: username: admin, password: admin username: guest, password: guest User admin has unlimited permissions, while guest can only view the application status. For security reason, you need to remove the default users admin and guest for cluster in production. Is this secure? Firstly, we will NOT store any user password in any way so only the user himself knows the password. We will use one-way hash digest to verify the user input password. How to develop a custom User-Password Authenticator for LDAP, Database, and etc.. If developer choose to define his/her own User-Password based authenticator, it is required that user modify configuration option: ## Replace \"io.gearpump.security.CustomAuthenticator\" with your real authenticator class. gearpump.ui-security.authenticator = \"io.gearpump.security.CustomAuthenticator\" Make sure CustomAuthenticator extends interface: trait Authenticator { def authenticate(user: String, password: String, ec: ExecutionContext): Future[AuthenticationResult] } OAuth2 based authentication OAuth2 based authentication is commonly use to achieve social login with social network account. Gearpump provides generic OAuth2 Authentication support which allow user to extend to support new authentication sources. Basically, OAuth2 based Authentication contains these steps: 1. User accesses Gearpump UI website, and choose to login with OAuth2 server. 2. Gearpump UI website redirects user to OAuth2 server domain authorization endpoint. 3. End user complete the authorization in the domain of OAuth2 server. 4. OAuth2 server redirects user back to Gearpump UI server. 5. Gearpump UI server verify the tokens and extract credentials from query parameters and form fields. Terminologies For terms like client Id, and client secret, please refers to guide RFC 6749 Enable web proxy for UI server To enable OAuth2 authentication, the Gearpump UI server should have network access to OAuth2 server, as some requests are initiated directly inside Gearpump UI server. So, if you are behind a firewall, make sure you have configured the proxy properly for UI server. If you are on Windows set JAVA_OPTS=-Dhttp.proxyHost=xx.com -Dhttp.proxyPort=8088 -Dhttps.proxyHost=xx.com -Dhttps.proxyPort=8088 bin/services If you are on Linux export JAVA_OPTS=\"-Dhttp.proxyHost=xx.com -Dhttp.proxyPort=8088 -Dhttps.proxyHost=xx.com -Dhttps.proxyPort=8088\" bin/services Google Plus OAuth2 Authenticator Google Plus OAuth2 Authenticator does authentication with Google OAuth2 service. It extracts the email address from Google user profile as credentials. To use Google OAuth2 Authenticator, there are several steps: Register your application (Gearpump UI server here) as an application to Google developer console. Configure the Google OAuth2 information in gear.conf Configure network proxy for Gearpump UI server if applies. Step1: Register your website as an OAuth2 Application on Google Create an application representing your website at https://console.developers.google.com In \"API Manager\" of your created application, enable API \"Google+ API\" Create OAuth client ID for this application. In \"Credentials\" tab of \"API Manager\", choose \"Create credentials\", and then select OAuth client ID. Follow the wizard to set callback URL, and generate client ID, and client Secret. NOTE: Callback URL is NOT optional. Step2: Configure the OAuth2 information in gear.conf Enable OAuth2 authentication by setting gearpump.ui-security.oauth2-authenticator-enabled as true. Configure section gearpump.ui-security.oauth2-authenticators.google in gear.conf. Please make sure class name, client ID, client Secret, and callback URL are set properly. NOTE: Callback URL set here should match what is configured on Google in step1. Step3: Configure the network proxy if applies. To enable OAuth2 authentication, the Gearpump UI server should have network access to Google service, as some requests are initiated directly inside Gearpump UI server. So, if you are behind a firewall, make sure you have configured the proxy properly for UI server. For guide of how to configure web proxy for UI server, please refer to section \"Enable web proxy for UI server\" above. Step4: Restart the UI server and try to click the Google login icon on UI server. CloudFoundry UAA server OAuth2 Authenticator CloudFoundryUaaAuthenticator does authentication by using CloudFoundry UAA OAuth2 service. It extracts the email address from Google user profile as credentials. For what is UAA (User Account and Authentication Service), please see guide: UAA To use Google OAuth2 Authenticator, there are several steps: Register your application (Gearpump UI server here) as an application to UAA with helper tool uaac . Configure the Google OAuth2 information in gear.conf Configure network proxy for Gearpump UI server if applies. Step1: Register your application to UAA with uaac Check tutorial on uaac at https://docs.cloudfoundry.org/adminguide/uaa-user-management.html Open a bash shell, set the UAA server by command uaac target uaac target [your uaa server url] Login in as user admin by uaac token client get admin -s MyAdminPassword Create a new Application (Client) in UAA, uaac client add [your_client_id] --scope \"openid cloud_controller.read\" --authorized_grant_types \"authorization_code client_credentials refresh_token\" --authorities \"openid cloud_controller.read\" --redirect_uri [your_redirect_url] --autoapprove true --secret [your_client_secret] Step2: Configure the OAuth2 information in gear.conf Enable OAuth2 authentication by setting gearpump.ui-security.oauth2-authenticator-enabled as true. Navigate to section gearpump.ui-security.oauth2-authenticators.cloudfoundryuaa Config gear.conf gearpump.ui-security.oauth2-authenticators.cloudfoundryuaa section. Please make sure class name, client ID, client Secret, and callback URL are set properly. NOTE: The callback URL here should match what you set on CloudFoundry UAA in step1. Step3: Configure network proxy for Gearpump UI server if applies To enable OAuth2 authentication, the Gearpump UI server should have network access to Google service, as some requests are initiated directly inside Gearpump UI server. So, if you are behind a firewall, make sure you have configured the proxy properly for UI server. For guide of how to configure web proxy for UI server, please refer to please refer to section \"Enable web proxy for UI server\" above. Step4: Restart the UI server and try to click the CloudFoundry login icon on UI server. Step5: You can also enable additional authenticator for CloudFoundry UAA by setting config: additional-authenticator-enabled = true Please see description in gear.conf for more information. Extends OAuth2Authenticator to support new Authorization service like Facebook, or Twitter. You can follow the Google OAuth2 example code to define a custom OAuth2Authenticator. Basically, the steps includes: Define an OAuth2Authenticator implementation. Add an configuration entry under gearpump.ui-security.oauth2-authenticators . For example: ## name of this authenticator \"socialnetworkx\" { \"class\" = \"io.gearpump.services.security.oauth2.impl.SocialNetworkXAuthenticator\" ## Please make sure this URL matches the name \"callback\" = \"http://127.0.0.1:8090/login/oauth2/socialnetworkx/callback\" \"clientId\" = \"gearpump_test2\" \"clientSecret\" = \"gearpump_test2\" \"defaultUserRole\" = \"guest\" ## Make sure socialnetworkx.png exists under dashboard/icons \"icon\" = \"/icons/socialnetworkx.png\" } The configuration entry is supposed to be used by class SocialNetworkXAuthenticator .","title":"UI Authentication"},{"location":"deployment/deployment-ui-authentication.html#what-is-this-about","text":"","title":"What is this about?"},{"location":"deployment/deployment-ui-authentication.html#how-to-enable-ui-authentication","text":"Change config file gear.conf, find entry gearpump-ui.gearpump.ui-security.authentication-enabled , change the value to true gearpump-ui.gearpump.ui-security.authentication-enabled = true Restart the UI dashboard, and then the UI authentication is enabled. It will prompt for user name and password.","title":"How to enable UI authentication?"},{"location":"deployment/deployment-ui-authentication.html#how-many-authentication-methods-gearpump-ui-server-support","text":"Currently, It supports: Username-Password based authentication and OAuth2 based authentication. User-Password based authentication is enabled when gearpump-ui.gearpump.ui-security.authentication-enabled , and CANNOT be disabled. UI server admin can also choose to enable auxiliary OAuth2 authentication channel.","title":"How many authentication methods Gearpump UI server support?"},{"location":"deployment/deployment-ui-authentication.html#user-password-based-authentication","text":"User-Password based authentication covers all authentication scenarios which requires user to enter an explicit username and password. Gearpump provides a built-in ConfigFileBasedAuthenticator which verify user name and password against password hashcode stored in config files. However, developer can choose to extends the io.gearpump.security.Authenticator to provide a custom User-Password based authenticator, to support LDAP, Kerberos, and Database-based authentication...","title":"User-Password based authentication"},{"location":"deployment/deployment-ui-authentication.html#configfilebasedauthenticator-built-in-user-password-authenticator","text":"ConfigFileBasedAuthenticator store all user name and password hashcode in configuration file gear.conf. Here is the steps to configure ConfigFileBasedAuthenticator.","title":"ConfigFileBasedAuthenticator: built-in User-Password Authenticator"},{"location":"deployment/deployment-ui-authentication.html#how-to-add-or-remove-user","text":"For the default authentication plugin, it has three categories of users: admins, users, and guests. admins: have unlimited permission, like shutdown a cluster, add/remove machines. users: have limited permission to submit an application and etc.. guests: can not submit/kill applications, but can view the application status. System administrator can add or remove user by updating config file conf/gear.conf . Suppose we want to add user jerry as an administrator, here are the steps: Pick a password, and generate the digest for this password. Suppose we use password ilovegearpump , to generate the digest: bin/gear io.gearpump.security.PasswordUtil -password ilovegearpump It will generate a digest value like this: CgGxGOxlU8ggNdOXejCeLxy+isrCv0TrS37HwA== Change config file conf/gear.conf at path gearpump-ui.gearpump.ui-security.config-file-based-authenticator.admins , add user jerry in this list: admins = { ## Default Admin. Username: admin, password: admin ## !!! Please replace this builtin account for production cluster for security reason. !!! \"admin\" = \"AeGxGOxlU8QENdOXejCeLxy+isrCv0TrS37HwA==\" \"jerry\" = \"CgGxGOxlU8ggNdOXejCeLxy+isrCv0TrS37HwA==\" } Restart the UI dashboard by bin/services to make the change effective. Group \"admins\" have very unlimited permission, you may want to restrict the permission. In that case you can modify gearpump-ui.gearpump.ui-security.config-file-based-authenticator.users or gearpump-ui.gearpump.ui-security.config-file-based-authenticator.guests . See description at conf/gear.conf to find more information.","title":"How to add or remove user?"},{"location":"deployment/deployment-ui-authentication.html#what-is-the-default-user-and-password","text":"For ConfigFileBasedAuthenticator, Gearpump distribution is shipped with two default users: username: admin, password: admin username: guest, password: guest User admin has unlimited permissions, while guest can only view the application status. For security reason, you need to remove the default users admin and guest for cluster in production.","title":"What is the default user and password?"},{"location":"deployment/deployment-ui-authentication.html#is-this-secure","text":"Firstly, we will NOT store any user password in any way so only the user himself knows the password. We will use one-way hash digest to verify the user input password.","title":"Is this secure?"},{"location":"deployment/deployment-ui-authentication.html#how-to-develop-a-custom-user-password-authenticator-for-ldap-database-and-etc","text":"If developer choose to define his/her own User-Password based authenticator, it is required that user modify configuration option: ## Replace \"io.gearpump.security.CustomAuthenticator\" with your real authenticator class. gearpump.ui-security.authenticator = \"io.gearpump.security.CustomAuthenticator\" Make sure CustomAuthenticator extends interface: trait Authenticator { def authenticate(user: String, password: String, ec: ExecutionContext): Future[AuthenticationResult] }","title":"How to develop a custom User-Password Authenticator for LDAP, Database, and etc.."},{"location":"deployment/deployment-ui-authentication.html#oauth2-based-authentication","text":"OAuth2 based authentication is commonly use to achieve social login with social network account. Gearpump provides generic OAuth2 Authentication support which allow user to extend to support new authentication sources. Basically, OAuth2 based Authentication contains these steps: 1. User accesses Gearpump UI website, and choose to login with OAuth2 server. 2. Gearpump UI website redirects user to OAuth2 server domain authorization endpoint. 3. End user complete the authorization in the domain of OAuth2 server. 4. OAuth2 server redirects user back to Gearpump UI server. 5. Gearpump UI server verify the tokens and extract credentials from query parameters and form fields.","title":"OAuth2 based authentication"},{"location":"deployment/deployment-ui-authentication.html#terminologies","text":"For terms like client Id, and client secret, please refers to guide RFC 6749","title":"Terminologies"},{"location":"deployment/deployment-ui-authentication.html#enable-web-proxy-for-ui-server","text":"To enable OAuth2 authentication, the Gearpump UI server should have network access to OAuth2 server, as some requests are initiated directly inside Gearpump UI server. So, if you are behind a firewall, make sure you have configured the proxy properly for UI server.","title":"Enable web proxy for UI server"},{"location":"deployment/deployment-ui-authentication.html#if-you-are-on-windows","text":"set JAVA_OPTS=-Dhttp.proxyHost=xx.com -Dhttp.proxyPort=8088 -Dhttps.proxyHost=xx.com -Dhttps.proxyPort=8088 bin/services","title":"If you are on Windows"},{"location":"deployment/deployment-ui-authentication.html#if-you-are-on-linux","text":"export JAVA_OPTS=\"-Dhttp.proxyHost=xx.com -Dhttp.proxyPort=8088 -Dhttps.proxyHost=xx.com -Dhttps.proxyPort=8088\" bin/services","title":"If you are on Linux"},{"location":"deployment/deployment-ui-authentication.html#google-plus-oauth2-authenticator","text":"Google Plus OAuth2 Authenticator does authentication with Google OAuth2 service. It extracts the email address from Google user profile as credentials. To use Google OAuth2 Authenticator, there are several steps: Register your application (Gearpump UI server here) as an application to Google developer console. Configure the Google OAuth2 information in gear.conf Configure network proxy for Gearpump UI server if applies.","title":"Google Plus OAuth2 Authenticator"},{"location":"deployment/deployment-ui-authentication.html#step1-register-your-website-as-an-oauth2-application-on-google","text":"Create an application representing your website at https://console.developers.google.com In \"API Manager\" of your created application, enable API \"Google+ API\" Create OAuth client ID for this application. In \"Credentials\" tab of \"API Manager\", choose \"Create credentials\", and then select OAuth client ID. Follow the wizard to set callback URL, and generate client ID, and client Secret. NOTE: Callback URL is NOT optional.","title":"Step1: Register your website as an OAuth2 Application on Google"},{"location":"deployment/deployment-ui-authentication.html#step2-configure-the-oauth2-information-in-gearconf","text":"Enable OAuth2 authentication by setting gearpump.ui-security.oauth2-authenticator-enabled as true. Configure section gearpump.ui-security.oauth2-authenticators.google in gear.conf. Please make sure class name, client ID, client Secret, and callback URL are set properly. NOTE: Callback URL set here should match what is configured on Google in step1.","title":"Step2: Configure the OAuth2 information in gear.conf"},{"location":"deployment/deployment-ui-authentication.html#step3-configure-the-network-proxy-if-applies","text":"To enable OAuth2 authentication, the Gearpump UI server should have network access to Google service, as some requests are initiated directly inside Gearpump UI server. So, if you are behind a firewall, make sure you have configured the proxy properly for UI server. For guide of how to configure web proxy for UI server, please refer to section \"Enable web proxy for UI server\" above.","title":"Step3: Configure the network proxy if applies."},{"location":"deployment/deployment-ui-authentication.html#step4-restart-the-ui-server-and-try-to-click-the-google-login-icon-on-ui-server","text":"","title":"Step4: Restart the UI server and try to click the Google login icon on UI server."},{"location":"deployment/deployment-ui-authentication.html#cloudfoundry-uaa-server-oauth2-authenticator","text":"CloudFoundryUaaAuthenticator does authentication by using CloudFoundry UAA OAuth2 service. It extracts the email address from Google user profile as credentials. For what is UAA (User Account and Authentication Service), please see guide: UAA To use Google OAuth2 Authenticator, there are several steps: Register your application (Gearpump UI server here) as an application to UAA with helper tool uaac . Configure the Google OAuth2 information in gear.conf Configure network proxy for Gearpump UI server if applies.","title":"CloudFoundry UAA server OAuth2 Authenticator"},{"location":"deployment/deployment-ui-authentication.html#step1-register-your-application-to-uaa-with-uaac","text":"Check tutorial on uaac at https://docs.cloudfoundry.org/adminguide/uaa-user-management.html Open a bash shell, set the UAA server by command uaac target uaac target [your uaa server url] Login in as user admin by uaac token client get admin -s MyAdminPassword Create a new Application (Client) in UAA, uaac client add [your_client_id] --scope \"openid cloud_controller.read\" --authorized_grant_types \"authorization_code client_credentials refresh_token\" --authorities \"openid cloud_controller.read\" --redirect_uri [your_redirect_url] --autoapprove true --secret [your_client_secret]","title":"Step1: Register your application to UAA with uaac"},{"location":"deployment/deployment-ui-authentication.html#step2-configure-the-oauth2-information-in-gearconf_1","text":"Enable OAuth2 authentication by setting gearpump.ui-security.oauth2-authenticator-enabled as true. Navigate to section gearpump.ui-security.oauth2-authenticators.cloudfoundryuaa Config gear.conf gearpump.ui-security.oauth2-authenticators.cloudfoundryuaa section. Please make sure class name, client ID, client Secret, and callback URL are set properly. NOTE: The callback URL here should match what you set on CloudFoundry UAA in step1.","title":"Step2: Configure the OAuth2 information in gear.conf"},{"location":"deployment/deployment-ui-authentication.html#step3-configure-network-proxy-for-gearpump-ui-server-if-applies","text":"To enable OAuth2 authentication, the Gearpump UI server should have network access to Google service, as some requests are initiated directly inside Gearpump UI server. So, if you are behind a firewall, make sure you have configured the proxy properly for UI server. For guide of how to configure web proxy for UI server, please refer to please refer to section \"Enable web proxy for UI server\" above.","title":"Step3: Configure network proxy for Gearpump UI server if applies"},{"location":"deployment/deployment-ui-authentication.html#step4-restart-the-ui-server-and-try-to-click-the-cloudfoundry-login-icon-on-ui-server","text":"","title":"Step4: Restart the UI server and try to click the CloudFoundry login icon on UI server."},{"location":"deployment/deployment-ui-authentication.html#step5-you-can-also-enable-additional-authenticator-for-cloudfoundry-uaa-by-setting-config","text":"additional-authenticator-enabled = true Please see description in gear.conf for more information.","title":"Step5: You can also enable additional authenticator for CloudFoundry UAA by setting config:"},{"location":"deployment/deployment-ui-authentication.html#extends-oauth2authenticator-to-support-new-authorization-service-like-facebook-or-twitter","text":"You can follow the Google OAuth2 example code to define a custom OAuth2Authenticator. Basically, the steps includes: Define an OAuth2Authenticator implementation. Add an configuration entry under gearpump.ui-security.oauth2-authenticators . For example: ## name of this authenticator \"socialnetworkx\" { \"class\" = \"io.gearpump.services.security.oauth2.impl.SocialNetworkXAuthenticator\" ## Please make sure this URL matches the name \"callback\" = \"http://127.0.0.1:8090/login/oauth2/socialnetworkx/callback\" \"clientId\" = \"gearpump_test2\" \"clientSecret\" = \"gearpump_test2\" \"defaultUserRole\" = \"guest\" ## Make sure socialnetworkx.png exists under dashboard/icons \"icon\" = \"/icons/socialnetworkx.png\" } The configuration entry is supposed to be used by class SocialNetworkXAuthenticator .","title":"Extends OAuth2Authenticator to support new Authorization service like Facebook, or Twitter."},{"location":"deployment/deployment-yarn.html","text":"How to launch a Gearpump cluster on YARN Upload the gearpump-2.12-0.9.0.zip to remote HDFS Folder, suggest to put it under /usr/lib/gearpump/gearpump-2.12-0.9.0.zip Make sure the home directory on HDFS is already created and all read-write rights are granted for user. For example, user gear's home directory is /user/gear Put the YARN configurations under classpath. Before calling yarnclient launch , make sure you have put all yarn configuration files under classpath. Typically, you can just copy all files under $HADOOP_HOME/etc/hadoop from one of the YARN Cluster machine to conf/yarnconf of gearpump. $HADOOP_HOME points to the Hadoop installation directory. Launch the gearpump cluster on YARN yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip If you don't specify package path, it will read default package-path ( gearpump.yarn.client.package-path ) from gear.conf . NOTE: You may need to execute chmod +x bin/* in shell to make the script file yarnclient executable. After launching, you can browser the Gearpump UI via YARN resource manager dashboard. How to configure the resource limitation of Gearpump cluster Before launching a Gearpump cluster, please change configuration section gearpump.yarn in gear.conf to configure the resource limitation, like: The number of worker containers. The YARN container memory size for worker and master. How to submit a application to Gearpump cluster. To submit the jar to the Gearpump cluster, we first need to know the Master address, so we need to get a active configuration file first. There are two ways to get an active configuration file: Option 1: specify \"-output\" option when you launch the cluster. yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip -output /tmp/mycluster.conf It will return in console like this: ==Application Id: application_1449802454214_0034 Option 2: Query the active configuration file yarnclient getconfig -appid <yarn application id> -output /tmp/mycluster.conf yarn application id can be found from the output of step1 or from YARN dashboard. After you downloaded the configuration file, you can launch application with that config file. gear app -jar examples/wordcount-2.12-0.9.0.jar -conf /tmp/mycluster.conf To run Storm application over Gearpump on YARN, please store the configuration file with -output application.conf and then launch Storm application with storm -jar examples/storm-2.12-0.9.0.jar storm.starter.ExclamationTopology exclamation Now the application is running. To check this: gear info -conf /tmp/mycluster.conf To Start a UI server, please do: services -conf /tmp/mycluster.conf The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users. How to add/remove machines dynamically. Gearpump yarn tool allows to dynamically add/remove machines. Here is the steps: First, query to get active resources. yarnclient query -appid <yarn application id> The console output will shows how many workers and masters there are. For example, I have output like this: masters: container_1449802454214_0034_01_000002(IDHV22-01:35712) workers: container_1449802454214_0034_01_000003(IDHV22-01:35712) container_1449802454214_0034_01_000006(IDHV22-01:35712) To add a new worker machine, you can do: yarnclient addworker -appid <yarn application id> -count 2 This will add two new workers machines. Run the command in first step to check whether the change is effective. To remove old machines, use: yarnclient removeworker -appid <yarn application id> -container <worker container id> The worker container id can be found from the output of step 1. For example \"container_1449802454214_0034_01_000006\" is a good container id. Other usage: To kill a cluster, yarnclient kill -appid <yarn application id> NOTE: If the application is not launched successfully, then this command won't work. Please use \"yarn application -kill \" instead. To check the Gearpump version yarnclient version -appid <yarn application id>","title":"YARN Mode"},{"location":"deployment/deployment-yarn.html#how-to-launch-a-gearpump-cluster-on-yarn","text":"Upload the gearpump-2.12-0.9.0.zip to remote HDFS Folder, suggest to put it under /usr/lib/gearpump/gearpump-2.12-0.9.0.zip Make sure the home directory on HDFS is already created and all read-write rights are granted for user. For example, user gear's home directory is /user/gear Put the YARN configurations under classpath. Before calling yarnclient launch , make sure you have put all yarn configuration files under classpath. Typically, you can just copy all files under $HADOOP_HOME/etc/hadoop from one of the YARN Cluster machine to conf/yarnconf of gearpump. $HADOOP_HOME points to the Hadoop installation directory. Launch the gearpump cluster on YARN yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip If you don't specify package path, it will read default package-path ( gearpump.yarn.client.package-path ) from gear.conf . NOTE: You may need to execute chmod +x bin/* in shell to make the script file yarnclient executable. After launching, you can browser the Gearpump UI via YARN resource manager dashboard.","title":"How to launch a Gearpump cluster on YARN"},{"location":"deployment/deployment-yarn.html#how-to-configure-the-resource-limitation-of-gearpump-cluster","text":"Before launching a Gearpump cluster, please change configuration section gearpump.yarn in gear.conf to configure the resource limitation, like: The number of worker containers. The YARN container memory size for worker and master.","title":"How to configure the resource limitation of Gearpump cluster"},{"location":"deployment/deployment-yarn.html#how-to-submit-a-application-to-gearpump-cluster","text":"To submit the jar to the Gearpump cluster, we first need to know the Master address, so we need to get a active configuration file first. There are two ways to get an active configuration file: Option 1: specify \"-output\" option when you launch the cluster. yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip -output /tmp/mycluster.conf It will return in console like this: ==Application Id: application_1449802454214_0034 Option 2: Query the active configuration file yarnclient getconfig -appid <yarn application id> -output /tmp/mycluster.conf yarn application id can be found from the output of step1 or from YARN dashboard. After you downloaded the configuration file, you can launch application with that config file. gear app -jar examples/wordcount-2.12-0.9.0.jar -conf /tmp/mycluster.conf To run Storm application over Gearpump on YARN, please store the configuration file with -output application.conf and then launch Storm application with storm -jar examples/storm-2.12-0.9.0.jar storm.starter.ExclamationTopology exclamation Now the application is running. To check this: gear info -conf /tmp/mycluster.conf To Start a UI server, please do: services -conf /tmp/mycluster.conf The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users.","title":"How to submit a application to Gearpump cluster."},{"location":"deployment/deployment-yarn.html#how-to-addremove-machines-dynamically","text":"Gearpump yarn tool allows to dynamically add/remove machines. Here is the steps: First, query to get active resources. yarnclient query -appid <yarn application id> The console output will shows how many workers and masters there are. For example, I have output like this: masters: container_1449802454214_0034_01_000002(IDHV22-01:35712) workers: container_1449802454214_0034_01_000003(IDHV22-01:35712) container_1449802454214_0034_01_000006(IDHV22-01:35712) To add a new worker machine, you can do: yarnclient addworker -appid <yarn application id> -count 2 This will add two new workers machines. Run the command in first step to check whether the change is effective. To remove old machines, use: yarnclient removeworker -appid <yarn application id> -container <worker container id> The worker container id can be found from the output of step 1. For example \"container_1449802454214_0034_01_000006\" is a good container id.","title":"How to add/remove machines dynamically."},{"location":"deployment/deployment-yarn.html#other-usage","text":"To kill a cluster, yarnclient kill -appid <yarn application id> NOTE: If the application is not launched successfully, then this command won't work. Please use \"yarn application -kill \" instead. To check the Gearpump version yarnclient version -appid <yarn application id>","title":"Other usage:"},{"location":"deployment/get-gearpump-distribution.html","text":"Prepare the binary You can either download pre-build release package or choose to build from source code. Download Release Binary If you choose to use pre-build package, then you don't need to build from source code. The release package can be downloaded from: Download page Build from Source code If you choose to build the package from source code yourself, you can follow these steps: 1). Clone the Gearpump repository git clone https://github.com/apache/incubator-gearpump.git cd gearpump 2). Build package ## Please use scala 2.11 ## The target package path: output/target/gearpump-2.12-0.9.0.zip sbt clean assembly packArchiveZip After the build, there will be a package file gearpump-2.12-0.9.0.zip generated under output/target/ folder. NOTE: Please set JAVA_HOME environment before the build. On linux: export JAVA_HOME={path/to/jdk/root/path} On Windows: set JAVA_HOME={path/to/jdk/root/path} NOTE: The build requires network connection. If you are behind an enterprise proxy, make sure you have set the proxy in your env before running the build commands. For windows: set HTTP_PROXY=http://host:port set HTTPS_PROXY= http://host:port For Linux: export HTTP_PROXY=http://host:port export HTTPS_PROXY= http://host:port Gearpump package structure You need to flatten the .zip file to use it. On Linux, you can unzip gearpump-2.12-0.9.0.zip After decompression, the directory structure looks like picture 1. Under bin/ folder, there are script files for Linux(bash script) and Windows(.bat script). script function local You can start the Gearpump cluster in single JVM(local mode), or in a distributed cluster(cluster mode). To start the cluster in local mode, you can use the local /local.bat helper scripts, it is very useful for developing or troubleshooting. master To start Gearpump in cluster mode, you need to start one or more master nodes, which represent the global resource management center. master/master.bat is launcher script to boot the master node. worker To start Gearpump in cluster mode, you also need to start several workers, with each worker represent a set of local resources. worker/worker.bat is launcher script to start the worker node. services This script is used to start backend REST service and other services for frontend UI dashboard (Default user \"admin, admin\"). Please check Command Line Syntax for more information for each script.","title":"How to Get Your Gearpump Distribution"},{"location":"deployment/get-gearpump-distribution.html#prepare-the-binary","text":"You can either download pre-build release package or choose to build from source code.","title":"Prepare the binary"},{"location":"deployment/get-gearpump-distribution.html#download-release-binary","text":"If you choose to use pre-build package, then you don't need to build from source code. The release package can be downloaded from:","title":"Download Release Binary"},{"location":"deployment/get-gearpump-distribution.html#download-page","text":"","title":"Download page"},{"location":"deployment/get-gearpump-distribution.html#build-from-source-code","text":"If you choose to build the package from source code yourself, you can follow these steps: 1). Clone the Gearpump repository git clone https://github.com/apache/incubator-gearpump.git cd gearpump 2). Build package ## Please use scala 2.11 ## The target package path: output/target/gearpump-2.12-0.9.0.zip sbt clean assembly packArchiveZip After the build, there will be a package file gearpump-2.12-0.9.0.zip generated under output/target/ folder. NOTE: Please set JAVA_HOME environment before the build. On linux: export JAVA_HOME={path/to/jdk/root/path} On Windows: set JAVA_HOME={path/to/jdk/root/path} NOTE: The build requires network connection. If you are behind an enterprise proxy, make sure you have set the proxy in your env before running the build commands. For windows: set HTTP_PROXY=http://host:port set HTTPS_PROXY= http://host:port For Linux: export HTTP_PROXY=http://host:port export HTTPS_PROXY= http://host:port","title":"Build from Source code"},{"location":"deployment/get-gearpump-distribution.html#gearpump-package-structure","text":"You need to flatten the .zip file to use it. On Linux, you can unzip gearpump-2.12-0.9.0.zip After decompression, the directory structure looks like picture 1. Under bin/ folder, there are script files for Linux(bash script) and Windows(.bat script). script function local You can start the Gearpump cluster in single JVM(local mode), or in a distributed cluster(cluster mode). To start the cluster in local mode, you can use the local /local.bat helper scripts, it is very useful for developing or troubleshooting. master To start Gearpump in cluster mode, you need to start one or more master nodes, which represent the global resource management center. master/master.bat is launcher script to boot the master node. worker To start Gearpump in cluster mode, you also need to start several workers, with each worker represent a set of local resources. worker/worker.bat is launcher script to start the worker node. services This script is used to start backend REST service and other services for frontend UI dashboard (Default user \"admin, admin\"). Please check Command Line Syntax for more information for each script.","title":"Gearpump package structure"},{"location":"deployment/hardware-requirement.html","text":"Pre-requisite Gearpump cluster can be installed on Windows OS and Linux. Before installation, you need to decide how many machines are used to run this cluster. For each machine, the requirements are listed in table below. Table: Environment requirement on single machine Resource Requirements Memory 2GB free memory is required to run the cluster. For any production system, 32GB memory is recommended. Java JRE 6 or above User permission Root permission is not required Network Ethernet (TCP/IP) CPU Nothing special HDFS installation Default is not required. You only need to install it when you want to store the application jars in HDFS. Kafka installation Default is not required. You need to install Kafka when you want the at-least once message delivery feature. Currently, the only supported data source for this feature is Kafka Table: The default port used in Gearpump: usage Port Description Dashboard UI 8090 Web UI. Dashboard web socket service 8091 UI backend web socket service for long connection. Master port 3000 Every other role like worker, appmaster, executor, user use this port to communicate with Master. You need to ensure that your firewall has not banned these ports to ensure Gearpump can work correctly. And you can modify the port configuration. Check Configuration section for details.","title":"Hardware Requirement"},{"location":"deployment/hardware-requirement.html#pre-requisite","text":"Gearpump cluster can be installed on Windows OS and Linux. Before installation, you need to decide how many machines are used to run this cluster. For each machine, the requirements are listed in table below. Table: Environment requirement on single machine Resource Requirements Memory 2GB free memory is required to run the cluster. For any production system, 32GB memory is recommended. Java JRE 6 or above User permission Root permission is not required Network Ethernet (TCP/IP) CPU Nothing special HDFS installation Default is not required. You only need to install it when you want to store the application jars in HDFS. Kafka installation Default is not required. You need to install Kafka when you want the at-least once message delivery feature. Currently, the only supported data source for this feature is Kafka Table: The default port used in Gearpump: usage Port Description Dashboard UI 8090 Web UI. Dashboard web socket service 8091 UI backend web socket service for long connection. Master port 3000 Every other role like worker, appmaster, executor, user use this port to communicate with Master. You need to ensure that your firewall has not banned these ports to ensure Gearpump can work correctly. And you can modify the port configuration. Check Configuration section for details.","title":"Pre-requisite"},{"location":"dev/dev-connectors.html","text":"Basic Concepts DataSource and DataSink are the two main concepts Gearpump use to connect with the outside world. DataSource DataSource is the start point of a streaming processing flow. DataSink DataSink is the end point of a streaming processing flow. Implemented Connectors DataSource implemented Currently, we have following DataSource supported. Name Description CollectionDataSource Convert a collection to a recursive data source. E.g. seq(1, 2, 3) will output 1,2,3,1,2,3... . KafkaSource Read from Kafka. DataSink implemented Currently, we have following DataSink supported. Name Description HBaseSink Write the message to HBase. The message to write must be HBase Put or a tuple of (rowKey, family, column, value) . KafkaSink Write to Kafka. Use of Connectors Use of Kafka connectors To use Kafka connectors in your application, you first need to add the gearpump-external-kafka library dependency in your application: SBT \"io.gearpump\" %% \"gearpump-external-kafka\" % 0.9.0 XML <dependency> <groupId>io.gearpump</groupId> <artifactId>gearpump-external-kafka</artifactId> <version>0.9.0</version> </dependency> This is a simple example to read from Kafka and write it back using KafkaSource and KafkaSink . Users can optionally set a CheckpointStoreFactory such that Kafka offsets are checkpointed and at-least-once message delivery is guaranteed. Low level API val appConfig = UserConfig.empty val props = new Properties props.put(KafkaConfig.ZOOKEEPER_CONNECT_CONFIG, zookeeperConnect) props.put(KafkaConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList) props.put(KafkaConfig.CHECKPOINT_STORE_NAME_PREFIX_CONFIG, appName) val source = new KafkaSource(sourceTopic, props) val checkpointStoreFactory = new KafkaStoreFactory(props) source.setCheckpointStore(checkpointStoreFactory) val sourceProcessor = DataSourceProcessor(source, sourceNum) val sink = new KafkaSink(sinkTopic, props) val sinkProcessor = DataSinkProcessor(sink, sinkNum) val partitioner = new ShufflePartitioner val computation = sourceProcessor ~ partitioner ~> sinkProcessor val app = StreamApplication(appName, Graph(computation), appConfig) High level API val props = new Properties val appName = \"KafkaDSL\" props.put(KafkaConfig.ZOOKEEPER_CONNECT_CONFIG, zookeeperConnect) props.put(KafkaConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList) props.put(KafkaConfig.CHECKPOINT_STORE_NAME_PREFIX_CONFIG, appName) val app = StreamApp(appName, context) if (atLeastOnce) { val checkpointStoreFactory = new KafkaStoreFactory(props) KafkaDSL.createAtLeastOnceStream(app, sourceTopic, checkpointStoreFactory, props, sourceNum) .writeToKafka(sinkTopic, props, sinkNum) } else { KafkaDSL.createAtMostOnceStream(app, sourceTopic, props, sourceNum) .writeToKafka(sinkTopic, props, sinkNum) } In the above example, configurations are set through Java properties and shared by KafkaSource , KafkaSink and KafkaCheckpointStoreFactory . Their configurations can be defined differently as below. KafkaSource configurations Name Descriptions Type Default KafkaConfig.ZOOKEEPER_CONNECT_CONFIG Zookeeper connect string for Kafka topics management String KafkaConfig.CLIENT_ID_CONFIG An id string to pass to the server when making requests String \"\" KafkaConfig.GROUP_ID_CONFIG A string that uniquely identifies a set of consumers within the same consumer group \"\" KafkaConfig.FETCH_SLEEP_MS_CONFIG The amount of time(ms) to sleep when hitting fetch.threshold Int 100 KafkaConfig.FETCH_THRESHOLD_CONFIG Size of internal queue to keep Kafka messages. Stop fetching and go to sleep when hitting the threshold Int 10000 KafkaConfig.PARTITION_GROUPER_CLASS_CONFIG Partition grouper class to group partitions among source tasks Class DefaultPartitionGrouper KafkaConfig.MESSAGE_DECODER_CLASS_CONFIG Message decoder class to decode raw bytes from Kafka Class DefaultMessageDecoder KafkaConfig.TIMESTAMP_FILTER_CLASS_CONFIG Timestamp filter class to filter out late messages Class DefaultTimeStampFilter KafkaSink configurations Name Descriptions Type Default KafkaConfig.BOOTSTRAP_SERVERS_CONFIG A list of host/port pairs to use for establishing the initial connection to the Kafka cluster String KafkaConfig.CLIENT_ID_CONFIG An id string to pass to the server when making requests String \"\" KafkaCheckpointStoreFactory configurations Name Descriptions Type Default KafkaConfig.ZOOKEEPER_CONNECT_CONFIG Zookeeper connect string for Kafka topics management String KafkaConfig.BOOTSTRAP_SERVERS_CONFIG A list of host/port pairs to use for establishing the initial connection to the Kafka cluster String KafkaConfig.CHECKPOINT_STORE_NAME_PREFIX Name prefix for checkpoint store String \"\" KafkaConfig.REPLICATION_FACTOR Replication factor for checkpoint store topic Int 1 Use of HBaseSink To use HBaseSink in your application, you first need to add the gearpump-external-hbase library dependency in your application: SBT \"io.gearpump\" %% \"gearpump-external-hbase\" % 0.9.0 XML <dependency> <groupId>io.gearpump</groupId> <artifactId>gearpump-external-hbase</artifactId> <version>0.9.0</version> </dependency> To connect to HBase, you need to provide following info: the HBase configuration to tell which HBase service to connect the table name (you must create the table yourself, see the HBase documentation ) Then, you can use HBaseSink in your application: //create the HBase data sink val sink = HBaseSink(UserConfig.empty, tableName, HBaseConfiguration.create()) //create Gearpump Processor val sinkProcessor = DataSinkProcessor(sink, parallelism) :::scala //assume stream is a normal `Stream` in DSL stream.writeToHbase(UserConfig.empty, tableName, parallelism, \"write to HBase\") You can tune the connection to HBase via the HBase configuration passed in. If not passed, Gearpump will try to check local classpath to find a valid HBase configuration ( hbase-site.xml ). Attention, due to the issue discussed here you may need to create additional configuration for your HBase sink: def hadoopConfig = { val conf = new Configuration() conf.set(\"hbase.zookeeper.quorum\", \"zookeeperHost\") conf.set(\"hbase.zookeeper.property.clientPort\", \"2181\") conf } val sink = HBaseSink(UserConfig.empty, tableName, hadoopConfig) How to implement your own DataSource To implement your own DataSource , you need to implement two things: The data source itself a helper class to easy the usage in a DSL Implement your own DataSource You need to implement a class derived from io.gearpump.streaming.transaction.api.TimeReplayableSource . Implement DSL helper (Optional) If you would like to have a DSL at hand you may start with this customized stream; it is better if you can implement your own DSL helper. You can refer KafkaDSLUtil as an example in Gearpump source. Below is some code snippet from KafkaDSLUtil : object KafkaDSLUtil { def createStream[T]( app: StreamApp, topics: String, parallelism: Int, description: String, properties: Properties): dsl.Stream[T] = { app.source[T](new KafkaSource(topics, properties), parallelism, description) } } How to implement your own DataSink To implement your own DataSink , you need to implement two things: The data sink itself a helper class to make it easy use in DSL Implement your own DataSink You need to implement a class derived from io.gearpump.streaming.sink.DataSink . Implement DSL helper (Optional) If you would like to have a DSL at hand you may start with this customized stream; it is better if you can implement your own DSL helper. You can refer HBaseDSLSink as an example in Gearpump source. Below is some code snippet from HBaseDSLSink : class HBaseDSLSink[T](stream: Stream[T]) { def writeToHbase(userConfig: UserConfig, table: String, parallism: Int, description: String): Stream[T] = { stream.sink(HBaseSink[T](userConfig, table), parallism, userConfig, description) } def writeToHbase(userConfig: UserConfig, configuration: Configuration, table: String, parallism: Int, description: String): Stream[T] = { stream.sink(HBaseSink[T](userConfig, table, configuration), parallism, userConfig, description) } } object HBaseDSLSink { implicit def streamToHBaseDSLSink[T](stream: Stream[T]): HBaseDSLSink[T] = { new HBaseDSLSink[T](stream) } }","title":"Gearpump Connectors"},{"location":"dev/dev-connectors.html#basic-concepts","text":"DataSource and DataSink are the two main concepts Gearpump use to connect with the outside world.","title":"Basic Concepts"},{"location":"dev/dev-connectors.html#datasource","text":"DataSource is the start point of a streaming processing flow.","title":"DataSource"},{"location":"dev/dev-connectors.html#datasink","text":"DataSink is the end point of a streaming processing flow.","title":"DataSink"},{"location":"dev/dev-connectors.html#implemented-connectors","text":"","title":"Implemented Connectors"},{"location":"dev/dev-connectors.html#datasource-implemented","text":"Currently, we have following DataSource supported. Name Description CollectionDataSource Convert a collection to a recursive data source. E.g. seq(1, 2, 3) will output 1,2,3,1,2,3... . KafkaSource Read from Kafka.","title":"DataSource implemented"},{"location":"dev/dev-connectors.html#datasink-implemented","text":"Currently, we have following DataSink supported. Name Description HBaseSink Write the message to HBase. The message to write must be HBase Put or a tuple of (rowKey, family, column, value) . KafkaSink Write to Kafka.","title":"DataSink implemented"},{"location":"dev/dev-connectors.html#use-of-connectors","text":"","title":"Use of Connectors"},{"location":"dev/dev-connectors.html#use-of-kafka-connectors","text":"To use Kafka connectors in your application, you first need to add the gearpump-external-kafka library dependency in your application:","title":"Use of Kafka connectors"},{"location":"dev/dev-connectors.html#sbt","text":"\"io.gearpump\" %% \"gearpump-external-kafka\" % 0.9.0","title":"SBT"},{"location":"dev/dev-connectors.html#xml","text":"<dependency> <groupId>io.gearpump</groupId> <artifactId>gearpump-external-kafka</artifactId> <version>0.9.0</version> </dependency> This is a simple example to read from Kafka and write it back using KafkaSource and KafkaSink . Users can optionally set a CheckpointStoreFactory such that Kafka offsets are checkpointed and at-least-once message delivery is guaranteed.","title":"XML"},{"location":"dev/dev-connectors.html#low-level-api","text":"val appConfig = UserConfig.empty val props = new Properties props.put(KafkaConfig.ZOOKEEPER_CONNECT_CONFIG, zookeeperConnect) props.put(KafkaConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList) props.put(KafkaConfig.CHECKPOINT_STORE_NAME_PREFIX_CONFIG, appName) val source = new KafkaSource(sourceTopic, props) val checkpointStoreFactory = new KafkaStoreFactory(props) source.setCheckpointStore(checkpointStoreFactory) val sourceProcessor = DataSourceProcessor(source, sourceNum) val sink = new KafkaSink(sinkTopic, props) val sinkProcessor = DataSinkProcessor(sink, sinkNum) val partitioner = new ShufflePartitioner val computation = sourceProcessor ~ partitioner ~> sinkProcessor val app = StreamApplication(appName, Graph(computation), appConfig)","title":"Low level API"},{"location":"dev/dev-connectors.html#high-level-api","text":"val props = new Properties val appName = \"KafkaDSL\" props.put(KafkaConfig.ZOOKEEPER_CONNECT_CONFIG, zookeeperConnect) props.put(KafkaConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList) props.put(KafkaConfig.CHECKPOINT_STORE_NAME_PREFIX_CONFIG, appName) val app = StreamApp(appName, context) if (atLeastOnce) { val checkpointStoreFactory = new KafkaStoreFactory(props) KafkaDSL.createAtLeastOnceStream(app, sourceTopic, checkpointStoreFactory, props, sourceNum) .writeToKafka(sinkTopic, props, sinkNum) } else { KafkaDSL.createAtMostOnceStream(app, sourceTopic, props, sourceNum) .writeToKafka(sinkTopic, props, sinkNum) } In the above example, configurations are set through Java properties and shared by KafkaSource , KafkaSink and KafkaCheckpointStoreFactory . Their configurations can be defined differently as below.","title":"High level API"},{"location":"dev/dev-connectors.html#kafkasource-configurations","text":"Name Descriptions Type Default KafkaConfig.ZOOKEEPER_CONNECT_CONFIG Zookeeper connect string for Kafka topics management String KafkaConfig.CLIENT_ID_CONFIG An id string to pass to the server when making requests String \"\" KafkaConfig.GROUP_ID_CONFIG A string that uniquely identifies a set of consumers within the same consumer group \"\" KafkaConfig.FETCH_SLEEP_MS_CONFIG The amount of time(ms) to sleep when hitting fetch.threshold Int 100 KafkaConfig.FETCH_THRESHOLD_CONFIG Size of internal queue to keep Kafka messages. Stop fetching and go to sleep when hitting the threshold Int 10000 KafkaConfig.PARTITION_GROUPER_CLASS_CONFIG Partition grouper class to group partitions among source tasks Class DefaultPartitionGrouper KafkaConfig.MESSAGE_DECODER_CLASS_CONFIG Message decoder class to decode raw bytes from Kafka Class DefaultMessageDecoder KafkaConfig.TIMESTAMP_FILTER_CLASS_CONFIG Timestamp filter class to filter out late messages Class DefaultTimeStampFilter","title":"KafkaSource configurations"},{"location":"dev/dev-connectors.html#kafkasink-configurations","text":"Name Descriptions Type Default KafkaConfig.BOOTSTRAP_SERVERS_CONFIG A list of host/port pairs to use for establishing the initial connection to the Kafka cluster String KafkaConfig.CLIENT_ID_CONFIG An id string to pass to the server when making requests String \"\"","title":"KafkaSink configurations"},{"location":"dev/dev-connectors.html#kafkacheckpointstorefactory-configurations","text":"Name Descriptions Type Default KafkaConfig.ZOOKEEPER_CONNECT_CONFIG Zookeeper connect string for Kafka topics management String KafkaConfig.BOOTSTRAP_SERVERS_CONFIG A list of host/port pairs to use for establishing the initial connection to the Kafka cluster String KafkaConfig.CHECKPOINT_STORE_NAME_PREFIX Name prefix for checkpoint store String \"\" KafkaConfig.REPLICATION_FACTOR Replication factor for checkpoint store topic Int 1","title":"KafkaCheckpointStoreFactory configurations"},{"location":"dev/dev-connectors.html#use-of-hbasesink","text":"To use HBaseSink in your application, you first need to add the gearpump-external-hbase library dependency in your application:","title":"Use of HBaseSink"},{"location":"dev/dev-connectors.html#sbt_1","text":"\"io.gearpump\" %% \"gearpump-external-hbase\" % 0.9.0","title":"SBT"},{"location":"dev/dev-connectors.html#xml_1","text":"<dependency> <groupId>io.gearpump</groupId> <artifactId>gearpump-external-hbase</artifactId> <version>0.9.0</version> </dependency> To connect to HBase, you need to provide following info: the HBase configuration to tell which HBase service to connect the table name (you must create the table yourself, see the HBase documentation ) Then, you can use HBaseSink in your application: //create the HBase data sink val sink = HBaseSink(UserConfig.empty, tableName, HBaseConfiguration.create()) //create Gearpump Processor val sinkProcessor = DataSinkProcessor(sink, parallelism) :::scala //assume stream is a normal `Stream` in DSL stream.writeToHbase(UserConfig.empty, tableName, parallelism, \"write to HBase\") You can tune the connection to HBase via the HBase configuration passed in. If not passed, Gearpump will try to check local classpath to find a valid HBase configuration ( hbase-site.xml ). Attention, due to the issue discussed here you may need to create additional configuration for your HBase sink: def hadoopConfig = { val conf = new Configuration() conf.set(\"hbase.zookeeper.quorum\", \"zookeeperHost\") conf.set(\"hbase.zookeeper.property.clientPort\", \"2181\") conf } val sink = HBaseSink(UserConfig.empty, tableName, hadoopConfig)","title":"XML"},{"location":"dev/dev-connectors.html#how-to-implement-your-own-datasource","text":"To implement your own DataSource , you need to implement two things: The data source itself a helper class to easy the usage in a DSL","title":"How to implement your own DataSource"},{"location":"dev/dev-connectors.html#implement-your-own-datasource","text":"You need to implement a class derived from io.gearpump.streaming.transaction.api.TimeReplayableSource .","title":"Implement your own DataSource"},{"location":"dev/dev-connectors.html#implement-dsl-helper-optional","text":"If you would like to have a DSL at hand you may start with this customized stream; it is better if you can implement your own DSL helper. You can refer KafkaDSLUtil as an example in Gearpump source. Below is some code snippet from KafkaDSLUtil : object KafkaDSLUtil { def createStream[T]( app: StreamApp, topics: String, parallelism: Int, description: String, properties: Properties): dsl.Stream[T] = { app.source[T](new KafkaSource(topics, properties), parallelism, description) } }","title":"Implement DSL helper (Optional)"},{"location":"dev/dev-connectors.html#how-to-implement-your-own-datasink","text":"To implement your own DataSink , you need to implement two things: The data sink itself a helper class to make it easy use in DSL","title":"How to implement your own DataSink"},{"location":"dev/dev-connectors.html#implement-your-own-datasink","text":"You need to implement a class derived from io.gearpump.streaming.sink.DataSink .","title":"Implement your own DataSink"},{"location":"dev/dev-connectors.html#implement-dsl-helper-optional_1","text":"If you would like to have a DSL at hand you may start with this customized stream; it is better if you can implement your own DSL helper. You can refer HBaseDSLSink as an example in Gearpump source. Below is some code snippet from HBaseDSLSink : class HBaseDSLSink[T](stream: Stream[T]) { def writeToHbase(userConfig: UserConfig, table: String, parallism: Int, description: String): Stream[T] = { stream.sink(HBaseSink[T](userConfig, table), parallism, userConfig, description) } def writeToHbase(userConfig: UserConfig, configuration: Configuration, table: String, parallism: Int, description: String): Stream[T] = { stream.sink(HBaseSink[T](userConfig, table, configuration), parallism, userConfig, description) } } object HBaseDSLSink { implicit def streamToHBaseDSLSink[T](stream: Stream[T]): HBaseDSLSink[T] = { new HBaseDSLSink[T](stream) } }","title":"Implement DSL helper (Optional)"},{"location":"dev/dev-custom-serializer.html","text":"Gearpump has a built-in serialization framework with a shaded Kryo version, which allows you to customize how a specific message type can be serialized. Register a class before serialization. Note, to use built-in kryo serialization framework, Gearpump requires all classes to be registered explicitly before using, no matter you want to use a custom serializer or not. If not using custom serializer, Gearpump will use default com.esotericsoftware.kryo.serializers.FieldSerializer to serialize the class. To register a class, you need to change the configuration file gear.conf(or application.conf if you want it only take effect for single application). gearpump { serializers { ## We will use default FieldSerializer to serialize this class type \"io.gearpump.UserMessage\" = \"\" ## we will use custom serializer to serialize this class type \"io.gearpump.UserMessage2\" = \"io.gearpump.UserMessageSerializer\" } } How to define a custom serializer for built-in kryo serialization framework When you decide that you want to define a custom serializer, you can do this in two ways. Please note that Gearpump shaded the original Kryo dependency. The package name com.esotericsoftware was relocated to io.gearpump.esotericsoftware . So in the following customization, you should import corresponding shaded classes, the example code will show that part. In general you should use the shaded version of a library whenever possible in order to avoid binary incompatibilities, eg don't use: import com.google.common.io.Files but rather import io.gearpump.google.common.io.Files System Level Serializer If the serializer is widely used, you can define a global serializer which is available to all applications(or worker or master) in the system. Step1: you first need to develop a java library which contains the custom serializer class. here is an example: package io.gearpump import io.gearpump.esotericsoftware.kryo.{Kryo, Serializer} import io.gearpump.esotericsoftware.kryo.io.{Input, Output} class UserMessage(longField: Long, intField: Int) class UserMessageSerializer extends Serializer[UserMessage] { override def write(kryo: Kryo, output: Output, obj: UserMessage) = { output.writeLong(obj.longField) output.writeInt(obj.intField) } override def read(kryo: Kryo, input: Input, typ: Class[UserMessage]): UserMessage = { val longField = input.readLong() val intField = input.readInt() new UserMessage(longField, intField) } } Step2: Distribute the libraries Distribute the jar file to lib/ folder of every Gearpump installation in the cluster. Step3: change gear.conf on every machine of the cluster: gearpump { serializers { \"io.gearpump.UserMessage\" = \"io.gearpump.UserMessageSerializer\" } } All set! Define Application level custom serializer If all you want is to define an application level serializer, which is only visible to current application AppMaster and Executors(including tasks), you can follow a different approach. Step1: Define your custom Serializer class You should include the Serializer class in your application jar. Here is an example to define a custom serializer: package io.gearpump import io.gearpump.esotericsoftware.kryo.{Kryo, Serializer} import io.gearpump.esotericsoftware.kryo.io.{Input, Output} class UserMessage(longField: Long, intField: Int) class UserMessageSerializer extends Serializer[UserMessage] { override def write(kryo: Kryo, output: Output, obj: UserMessage) = { output.writeLong(obj.longField) output.writeInt(obj.intField) } override def read(kryo: Kryo, input: Input, typ: Class[UserMessage]): UserMessage = { val longField = input.readLong() val intField = input.readInt() new UserMessage(longField, intField) } } Step2: Put a application.conf in your classpath on Client machine where you submit the application, ### content of application.conf gearpump { serializers { \"io.gearpump.UserMessage\" = \"io.gearpump.UserMessageSerializer\" } } Step3: All set! Advanced: Choose another serialization framework Note: This is only for advanced user which require deep customization of Gearpump platform. There are other serialization framework besides Kryo, like Protobuf. If user don't want to use the built-in kryo serialization framework, he can customize a new serialization framework. basically, user need to define in gear.conf(or application.conf for single application's scope) file like this: gearpump.serialization-framework = \"io.gearpump.serializer.CustomSerializationFramework\" Please find an example in gearpump storm module, search \"StormSerializationFramework\" in source code.","title":"Customized Message Passing"},{"location":"dev/dev-custom-serializer.html#register-a-class-before-serialization","text":"Note, to use built-in kryo serialization framework, Gearpump requires all classes to be registered explicitly before using, no matter you want to use a custom serializer or not. If not using custom serializer, Gearpump will use default com.esotericsoftware.kryo.serializers.FieldSerializer to serialize the class. To register a class, you need to change the configuration file gear.conf(or application.conf if you want it only take effect for single application). gearpump { serializers { ## We will use default FieldSerializer to serialize this class type \"io.gearpump.UserMessage\" = \"\" ## we will use custom serializer to serialize this class type \"io.gearpump.UserMessage2\" = \"io.gearpump.UserMessageSerializer\" } }","title":"Register a class before serialization."},{"location":"dev/dev-custom-serializer.html#how-to-define-a-custom-serializer-for-built-in-kryo-serialization-framework","text":"When you decide that you want to define a custom serializer, you can do this in two ways. Please note that Gearpump shaded the original Kryo dependency. The package name com.esotericsoftware was relocated to io.gearpump.esotericsoftware . So in the following customization, you should import corresponding shaded classes, the example code will show that part. In general you should use the shaded version of a library whenever possible in order to avoid binary incompatibilities, eg don't use: import com.google.common.io.Files but rather import io.gearpump.google.common.io.Files","title":"How to define a custom serializer for built-in kryo serialization framework"},{"location":"dev/dev-custom-serializer.html#system-level-serializer","text":"If the serializer is widely used, you can define a global serializer which is available to all applications(or worker or master) in the system.","title":"System Level Serializer"},{"location":"dev/dev-custom-serializer.html#step1-you-first-need-to-develop-a-java-library-which-contains-the-custom-serializer-class-here-is-an-example","text":"package io.gearpump import io.gearpump.esotericsoftware.kryo.{Kryo, Serializer} import io.gearpump.esotericsoftware.kryo.io.{Input, Output} class UserMessage(longField: Long, intField: Int) class UserMessageSerializer extends Serializer[UserMessage] { override def write(kryo: Kryo, output: Output, obj: UserMessage) = { output.writeLong(obj.longField) output.writeInt(obj.intField) } override def read(kryo: Kryo, input: Input, typ: Class[UserMessage]): UserMessage = { val longField = input.readLong() val intField = input.readInt() new UserMessage(longField, intField) } }","title":"Step1: you first need to develop a java library which contains the custom serializer class. here is an example:"},{"location":"dev/dev-custom-serializer.html#step2-distribute-the-libraries","text":"Distribute the jar file to lib/ folder of every Gearpump installation in the cluster.","title":"Step2: Distribute the libraries"},{"location":"dev/dev-custom-serializer.html#step3-change-gearconf-on-every-machine-of-the-cluster","text":"gearpump { serializers { \"io.gearpump.UserMessage\" = \"io.gearpump.UserMessageSerializer\" } }","title":"Step3: change gear.conf on every machine of the cluster:"},{"location":"dev/dev-custom-serializer.html#all-set","text":"","title":"All set!"},{"location":"dev/dev-custom-serializer.html#define-application-level-custom-serializer","text":"If all you want is to define an application level serializer, which is only visible to current application AppMaster and Executors(including tasks), you can follow a different approach.","title":"Define Application level custom serializer"},{"location":"dev/dev-custom-serializer.html#step1-define-your-custom-serializer-class","text":"You should include the Serializer class in your application jar. Here is an example to define a custom serializer: package io.gearpump import io.gearpump.esotericsoftware.kryo.{Kryo, Serializer} import io.gearpump.esotericsoftware.kryo.io.{Input, Output} class UserMessage(longField: Long, intField: Int) class UserMessageSerializer extends Serializer[UserMessage] { override def write(kryo: Kryo, output: Output, obj: UserMessage) = { output.writeLong(obj.longField) output.writeInt(obj.intField) } override def read(kryo: Kryo, input: Input, typ: Class[UserMessage]): UserMessage = { val longField = input.readLong() val intField = input.readInt() new UserMessage(longField, intField) } }","title":"Step1: Define your custom Serializer class"},{"location":"dev/dev-custom-serializer.html#step2-put-a-applicationconf-in-your-classpath-on-client-machine-where-you-submit-the-application","text":"### content of application.conf gearpump { serializers { \"io.gearpump.UserMessage\" = \"io.gearpump.UserMessageSerializer\" } }","title":"Step2: Put a application.conf in your classpath on Client machine where you submit the application,"},{"location":"dev/dev-custom-serializer.html#step3-all-set","text":"","title":"Step3: All set!"},{"location":"dev/dev-custom-serializer.html#advanced-choose-another-serialization-framework","text":"Note: This is only for advanced user which require deep customization of Gearpump platform. There are other serialization framework besides Kryo, like Protobuf. If user don't want to use the built-in kryo serialization framework, he can customize a new serialization framework. basically, user need to define in gear.conf(or application.conf for single application's scope) file like this: gearpump.serialization-framework = \"io.gearpump.serializer.CustomSerializationFramework\" Please find an example in gearpump storm module, search \"StormSerializationFramework\" in source code.","title":"Advanced: Choose another serialization framework"},{"location":"dev/dev-ide-setup.html","text":"Intellij IDE Setup In Intellij, download scala plugin. We are using scala version 2.12 Open menu \"File->Open\" to open Gearpump root project, then choose the Gearpump source folder. All set. NOTE: Intellij Scala plugin is already bundled with sbt. If you have Scala plugin installed, please don't install additional sbt plugin. Check your settings at \"Settings -> Plugins\" NOTE: If you are behind a proxy, to speed up the build, please set the proxy for sbt in \"Settings -> Build Tools > SBT\". in input field \"VM parameters\", add -Dhttp.proxyHost=<proxy host> -Dhttp.proxyPort=<port like 911> -Dhttps.proxyHost=<proxy host> -Dhttps.proxyPort=<port like 911> Eclipse IDE Setup I will show how to do this in eclipse LUNA. There is a sbt-eclipse plugin to generate eclipse project files, but seems there are some bugs, and some manual fix is still required. Here is the steps that works for me: Install latest version eclipse luna Install latest scala-IDE http://scala-ide.org/download/current.html I use update site address: http://download.scala-ide.org/sdk/lithium/e44/scala211/stable/site Open a sbt shell under the root folder of Gearpump. enter \"eclipse\", then we get all eclipse project file generated. Use eclipse import wizard. File->Import->Existing projects into Workspace, make sure to tick the option \"Search for nested projects\" Then it may starts to complain about encoding error, like \"IO error while decoding\". You need to fix the eclipse default text encoding by changing configuration at \"Window->Preference->General->Workspace->Text file encoding\" to UTF-8. Then the project gearpump-external-kafka may still cannot compile. The reason is that there is some dependencies missing in generated .classpath file by sbt-eclipse. We need to do some manual fix. Right click on project icon of gearpump-external-kafka in eclipse, then choose menu \"Build Path->Configure Build Path\". A window will popup. Under the tab \"projects\", click add, choose \"gearpump-streaming\" All set. Now the project should compile OK in eclipse.","title":"IDE Setup"},{"location":"dev/dev-ide-setup.html#intellij-ide-setup","text":"In Intellij, download scala plugin. We are using scala version 2.12 Open menu \"File->Open\" to open Gearpump root project, then choose the Gearpump source folder. All set. NOTE: Intellij Scala plugin is already bundled with sbt. If you have Scala plugin installed, please don't install additional sbt plugin. Check your settings at \"Settings -> Plugins\" NOTE: If you are behind a proxy, to speed up the build, please set the proxy for sbt in \"Settings -> Build Tools > SBT\". in input field \"VM parameters\", add -Dhttp.proxyHost=<proxy host> -Dhttp.proxyPort=<port like 911> -Dhttps.proxyHost=<proxy host> -Dhttps.proxyPort=<port like 911>","title":"Intellij IDE Setup"},{"location":"dev/dev-ide-setup.html#eclipse-ide-setup","text":"I will show how to do this in eclipse LUNA. There is a sbt-eclipse plugin to generate eclipse project files, but seems there are some bugs, and some manual fix is still required. Here is the steps that works for me: Install latest version eclipse luna Install latest scala-IDE http://scala-ide.org/download/current.html I use update site address: http://download.scala-ide.org/sdk/lithium/e44/scala211/stable/site Open a sbt shell under the root folder of Gearpump. enter \"eclipse\", then we get all eclipse project file generated. Use eclipse import wizard. File->Import->Existing projects into Workspace, make sure to tick the option \"Search for nested projects\" Then it may starts to complain about encoding error, like \"IO error while decoding\". You need to fix the eclipse default text encoding by changing configuration at \"Window->Preference->General->Workspace->Text file encoding\" to UTF-8. Then the project gearpump-external-kafka may still cannot compile. The reason is that there is some dependencies missing in generated .classpath file by sbt-eclipse. We need to do some manual fix. Right click on project icon of gearpump-external-kafka in eclipse, then choose menu \"Build Path->Configure Build Path\". A window will popup. Under the tab \"projects\", click add, choose \"gearpump-streaming\" All set. Now the project should compile OK in eclipse.","title":"Eclipse IDE Setup"},{"location":"dev/dev-non-streaming-example.html","text":"We'll use Distributed Shell as an example to illustrate how to do that. What Distributed Shell do is that user send a shell command to the cluster and the command will the executed on each node, then the result will be return to user. Maven/Sbt Settings Repository and library dependencies can be found at Maven Setting Define Executor Class class ShellExecutor(executorContext: ExecutorContext, userConf : UserConfig) extends Actor{ import executorContext._ override def receive: Receive = { case ShellCommand(command, args) => val process = Try(s\"$command $args\" !!) val result = process match { case Success(msg) => msg case Failure(ex) => ex.getMessage } sender ! ShellCommandResult(executorId, result) } } So ShellExecutor just receive the ShellCommand and try to execute it and return the result to the sender, which is quite simple. Define AppMaster Class For a non-streaming application, you have to write your own AppMaster. Here is a typical user defined AppMaster, please note that some trivial codes are omitted. class DistShellAppMaster(appContext : AppMasterContext, app : Application) extends ApplicationMaster { protected var currentExecutorId = 0 override def preStart(): Unit = { ActorUtil.launchExecutorOnEachWorker(masterProxy, getExecutorJvmConfig, self) } override def receive: Receive = { case ExecutorSystemStarted(executorSystem) => import executorSystem.{address, worker, resource => executorResource} val executorContext = ExecutorContext(currentExecutorId, worker.workerId, appId, self, executorResource) val executor = context.actorOf(Props(classOf[ShellExecutor], executorContext, app.userConfig) .withDeploy(Deploy(scope = RemoteScope(address))), currentExecutorId.toString) executorSystem.bindLifeCycleWith(executor) currentExecutorId += 1 case StartExecutorSystemTimeout => masterProxy ! ShutdownApplication(appId) context.stop(self) case msg: ShellCommand => Future.fold(context.children.map(_ ? msg))(new ShellCommandResultAggregator) { (aggregator, response) => aggregator.aggregate(response.asInstanceOf[ShellCommandResult]) }.map(_.toString()) pipeTo sender } private def getExecutorJvmConfig: ExecutorSystemJvmConfig = { val config: Config = Option(app.clusterConfig).map(_.getConfig).getOrElse(ConfigFactory.empty()) val jvmSetting = Util.resolveJvmSetting(config.withFallback(context.system.settings.config)).executor ExecutorSystemJvmConfig(jvmSetting.classPath, jvmSetting.vmargs, appJar, username, config) } } So when this DistShellAppMaster started, first it will request resources to launch one executor on each node, which is done in method preStart Then the DistShellAppMaster's receive handler will handle the allocated resource to launch the ShellExecutor we want. If you want to write your application, you can just use this part of code. The only thing needed is replacing the Executor class. There may be a situation that the resource allocation failed which will bring the message StartExecutorSystemTimeout , the normal pattern to handle that is just what we do: shut down the application. The real application logic part is in ShellCommand message handler, which is specific to different applications. Here we distribute the shell command to each executor and aggregate the results to the client. For method getExecutorJvmConfig , you can just use this part of code in your own application. Define Application Now its time to launch the application. object DistributedShell extends App with ArgumentsParser { private val LOG: Logger = LogUtil.getLogger(getClass) override val options: Array[(String, CLIOption[Any])] = Array.empty LOG.info(s\"Distributed shell submitting application...\") val context = ClientContext() val appId = context.submit(Application[DistShellAppMaster](\"DistributedShell\", UserConfig.empty)) context.close() LOG.info(s\"Distributed Shell Application started with appId $appId !\") } The application class extends App and `ArgumentsParser which make it easier to parse arguments and run main functions. This part is similar to the streaming applications. The main class DistributeShell will submit an application to Master , whose AppMaster is DistShellAppMaster . Define an optional Client class Now, we can define a Client class to talk with AppMaster to pass our commands to it. object DistributedShellClient extends App with ArgumentsParser { implicit val timeout = Constants.FUTURE_TIMEOUT import scala.concurrent.ExecutionContext.Implicits.global private val LOG: Logger = LoggerFactory.getLogger(getClass) override val options: Array[(String, CLIOption[Any])] = Array( \"master\" -> CLIOption[String](\"<host1:port1,host2:port2,host3:port3>\", required = true), \"appid\" -> CLIOption[Int](\"<the distributed shell appid>\", required = true), \"command\" -> CLIOption[String](\"<shell command>\", required = true), \"args\" -> CLIOption[String](\"<shell arguments>\", required = true) ) val config = parse(args) val context = ClientContext(config.getString(\"master\")) val appid = config.getInt(\"appid\") val command = config.getString(\"command\") val arguments = config.getString(\"args\") val appMaster = context.resolveAppID(appid) (appMaster ? ShellCommand(command, arguments)).map { reslut => LOG.info(s\"Result: $reslut\") context.close() } } In the DistributedShellClient , it will resolve the appid to the real appmaster(the application id will be printed when launching DistributedShell ). Once we got the AppMaster , then we can send ShellCommand to it and wait for the result. Submit application After all these, you need to package everything into a uber jar and submit the jar to Gearpump Cluster. Please check Application submission tool to command line tool syntax.","title":"Non Streaming Examples"},{"location":"dev/dev-non-streaming-example.html#mavensbt-settings","text":"Repository and library dependencies can be found at Maven Setting","title":"Maven/Sbt Settings"},{"location":"dev/dev-non-streaming-example.html#define-executor-class","text":"class ShellExecutor(executorContext: ExecutorContext, userConf : UserConfig) extends Actor{ import executorContext._ override def receive: Receive = { case ShellCommand(command, args) => val process = Try(s\"$command $args\" !!) val result = process match { case Success(msg) => msg case Failure(ex) => ex.getMessage } sender ! ShellCommandResult(executorId, result) } } So ShellExecutor just receive the ShellCommand and try to execute it and return the result to the sender, which is quite simple.","title":"Define Executor Class"},{"location":"dev/dev-non-streaming-example.html#define-appmaster-class","text":"For a non-streaming application, you have to write your own AppMaster. Here is a typical user defined AppMaster, please note that some trivial codes are omitted. class DistShellAppMaster(appContext : AppMasterContext, app : Application) extends ApplicationMaster { protected var currentExecutorId = 0 override def preStart(): Unit = { ActorUtil.launchExecutorOnEachWorker(masterProxy, getExecutorJvmConfig, self) } override def receive: Receive = { case ExecutorSystemStarted(executorSystem) => import executorSystem.{address, worker, resource => executorResource} val executorContext = ExecutorContext(currentExecutorId, worker.workerId, appId, self, executorResource) val executor = context.actorOf(Props(classOf[ShellExecutor], executorContext, app.userConfig) .withDeploy(Deploy(scope = RemoteScope(address))), currentExecutorId.toString) executorSystem.bindLifeCycleWith(executor) currentExecutorId += 1 case StartExecutorSystemTimeout => masterProxy ! ShutdownApplication(appId) context.stop(self) case msg: ShellCommand => Future.fold(context.children.map(_ ? msg))(new ShellCommandResultAggregator) { (aggregator, response) => aggregator.aggregate(response.asInstanceOf[ShellCommandResult]) }.map(_.toString()) pipeTo sender } private def getExecutorJvmConfig: ExecutorSystemJvmConfig = { val config: Config = Option(app.clusterConfig).map(_.getConfig).getOrElse(ConfigFactory.empty()) val jvmSetting = Util.resolveJvmSetting(config.withFallback(context.system.settings.config)).executor ExecutorSystemJvmConfig(jvmSetting.classPath, jvmSetting.vmargs, appJar, username, config) } } So when this DistShellAppMaster started, first it will request resources to launch one executor on each node, which is done in method preStart Then the DistShellAppMaster's receive handler will handle the allocated resource to launch the ShellExecutor we want. If you want to write your application, you can just use this part of code. The only thing needed is replacing the Executor class. There may be a situation that the resource allocation failed which will bring the message StartExecutorSystemTimeout , the normal pattern to handle that is just what we do: shut down the application. The real application logic part is in ShellCommand message handler, which is specific to different applications. Here we distribute the shell command to each executor and aggregate the results to the client. For method getExecutorJvmConfig , you can just use this part of code in your own application.","title":"Define AppMaster Class"},{"location":"dev/dev-non-streaming-example.html#define-application","text":"Now its time to launch the application. object DistributedShell extends App with ArgumentsParser { private val LOG: Logger = LogUtil.getLogger(getClass) override val options: Array[(String, CLIOption[Any])] = Array.empty LOG.info(s\"Distributed shell submitting application...\") val context = ClientContext() val appId = context.submit(Application[DistShellAppMaster](\"DistributedShell\", UserConfig.empty)) context.close() LOG.info(s\"Distributed Shell Application started with appId $appId !\") } The application class extends App and `ArgumentsParser which make it easier to parse arguments and run main functions. This part is similar to the streaming applications. The main class DistributeShell will submit an application to Master , whose AppMaster is DistShellAppMaster .","title":"Define Application"},{"location":"dev/dev-non-streaming-example.html#define-an-optional-client-class","text":"Now, we can define a Client class to talk with AppMaster to pass our commands to it. object DistributedShellClient extends App with ArgumentsParser { implicit val timeout = Constants.FUTURE_TIMEOUT import scala.concurrent.ExecutionContext.Implicits.global private val LOG: Logger = LoggerFactory.getLogger(getClass) override val options: Array[(String, CLIOption[Any])] = Array( \"master\" -> CLIOption[String](\"<host1:port1,host2:port2,host3:port3>\", required = true), \"appid\" -> CLIOption[Int](\"<the distributed shell appid>\", required = true), \"command\" -> CLIOption[String](\"<shell command>\", required = true), \"args\" -> CLIOption[String](\"<shell arguments>\", required = true) ) val config = parse(args) val context = ClientContext(config.getString(\"master\")) val appid = config.getInt(\"appid\") val command = config.getString(\"command\") val arguments = config.getString(\"args\") val appMaster = context.resolveAppID(appid) (appMaster ? ShellCommand(command, arguments)).map { reslut => LOG.info(s\"Result: $reslut\") context.close() } } In the DistributedShellClient , it will resolve the appid to the real appmaster(the application id will be printed when launching DistributedShell ). Once we got the AppMaster , then we can send ShellCommand to it and wait for the result.","title":"Define an optional Client class"},{"location":"dev/dev-non-streaming-example.html#submit-application","text":"After all these, you need to package everything into a uber jar and submit the jar to Gearpump Cluster. Please check Application submission tool to command line tool syntax.","title":"Submit application"},{"location":"dev/dev-rest-api.html","text":"Authentication. For all REST API calls, We need authentication by default. If you don't want authentication, you can disable them. How to disable Authentication To disable Authentication, you can set gearpump-ui.gearpump.ui-security.authentication-enabled = false in gear.conf, please check UI Authentication for details. How to authenticate if Authentication is enabled. For User-Password based authentication If Authentication is enabled, then you need to login before calling REST API. curl -X POST --data username=admin --data password=admin --cookie-jar outputAuthenticationCookie.txt http://127.0.0.1:8090/login This will use default user \"admin:admin\" to login, and store the authentication cookie to file outputAuthenticationCookie.txt. In All subsequent Rest API calls, you need to add the authentication cookie. For example curl --cookie outputAuthenticationCookie.txt http://127.0.0.1/api/v1.0/master for more information, please check UI Authentication . For OAuth2 based authentication For OAuth2 based authentication, it requires you to have an access token in place. Different OAuth2 service provider have different way to return an access token. For Google , you can refer to OAuth Doc . For CloudFoundry UAA , you can use the uaac command to get the access token. $ uaac target http://login.gearpump.gotapaas.eu/ $ uaac token get <user_email_address> ### Find access token $ uaac context [0]*[http://login.gearpump.gotapaas.eu] [0]*[<user_email_address>] user_id: 34e33a79-42c6-479b-a8c1-8c471ff027fb client_id: cf token_type: bearer access_token: eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiI expires_in: 599 scope: password.write openid cloud_controller.write cloud_controller.read jti: 74ea49e4-1001-4757-9f8d-a66e52a27557 For more information on uaac, please check UAAC guide Now, we have the access token, then let's login to Gearpump UI server with this access token: ## Please replace cloudfoundryuaa with actual OAuth2 service name you have configured in gear.conf curl -X POST --data accesstoken=eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiI --cookie-jar outputAuthenticationCookie.txt http://127.0.0.1:8090/login/oauth2/cloudfoundryuaa/accesstoken This will use user user_email_address to login, and store the authentication cookie to file outputAuthenticationCookie.txt. In All subsequent Rest API calls, you need to add the authentication cookie. For example curl --cookie outputAuthenticationCookie.txt http://127.0.0.1/api/v1.0/master NOTE: You can default the default permission level for OAuth2 user. for more information, please check UI Authentication . Query version GET version Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/version Sample Response: 0.9.0 Master Service GET api/v1.0/master Get information of masters Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master Sample Response: { \"masterDescription\": { \"leader\":{\"host\":\"master@127.0.0.1\",\"port\":3000}, \"cluster\":[{\"host\":\"127.0.0.1\",\"port\":3000}] \"aliveFor\": \"642941\", \"logFile\": \"/Users/foobar/gearpump/logs\", \"jarStore\": \"jarstore/\", \"masterStatus\": \"synced\", \"homeDirectory\": \"/Users/foobar/gearpump\" } } GET api/v1.0/master/applist Query information of all applications Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/applist Sample Response: { \"appMasters\": [ { \"status\": \"active\", \"appId\": 1, \"appName\": \"wordCount\", \"appMasterPath\": \"akka.tcp://app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c\", \"workerPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker0\", \"submissionTime\": \"1450758114766\", \"startTime\": \"1450758117294\", \"user\": \"lisa\" } ] } GET api/v1.0/master/workerlist Query information of all workers Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/workerlist Sample Response: [ { \"workerId\": \"1\", \"state\": \"active\", \"actorPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker0\", \"aliveFor\": \"431565\", \"logFile\": \"logs/\", \"executors\": [ { \"appId\": 1, \"executorId\": -1, \"slots\": 1 }, { \"appId\": 1, \"executorId\": 0, \"slots\": 1 } ], \"totalSlots\": 1000, \"availableSlots\": 998, \"homeDirectory\": \"/usr/lisa/gearpump/\", \"jvmName\": \"11788@lisa\" }, { \"workerId\": \"0\", \"state\": \"active\", \"actorPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker1\", \"aliveFor\": \"431546\", \"logFile\": \"logs/\", \"executors\": [ { \"appId\": 1, \"executorId\": 1, \"slots\": 1 } ], \"totalSlots\": 1000, \"availableSlots\": 999, \"homeDirectory\": \"/usr/lisa/gearpump/\", \"jvmName\": \"11788@lisa\" } ] GET api/v1.0/master/config Get the configuration of all masters Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/config Sample Response: { \"extensions\": [ \"akka.contrib.datareplication.DataReplication$\" ] \"akka\": { \"loglevel\": \"INFO\" \"log-dead-letters\": \"off\" \"log-dead-letters-during-shutdown\": \"off\" \"actor\": { ## Master forms a akka cluster \"provider\": \"akka.cluster.ClusterActorRefProvider\" } \"cluster\": { \"roles\": [\"master\"] \"auto-down-unreachable-after\": \"15s\" } \"remote\": { \"log-remote-lifecycle-events\": \"off\" } } } GET api/v1.0/master/metrics/<query_path>?readLatest=<true|false> Get the master node metrics. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/metrics/master?readLatest=true Sample Response: { \"path\" : \"master\", \"metrics\" : [{ \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.heap.used\", \"value\": \"59764272\"} }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450758725070\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.total.max\", \"value\": \"997457920\"} }, { \"time\": \"1450758725070\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.total.used\", \"value\": \"89117352\"} }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:thread.count\", \"value\": \"28\"} }] } POST api/v1.0/master/submitapp Submit a streaming job jar to Gearpump cluster. It functions like command line gear app -jar xx.jar -conf yy.conf -executors 1 <command line arguments> Required MIME type: \"multipart/form-data\" Required post form fields: field name \"jar\", job jar file. Optional post form fields: \"configfile\", configuration file, in UTF8 format. \"configstring\", text body of configuration file, in UTF8 format. \"executorcount\", The count of JVM process to start across the cluster for this application job \"args\", command line arguments for this job jar. Example html: <form id=\"submitapp\" action=\"http://127.0.0.1:8090/api/v1.0/master/submitapp\" method=\"POST\" enctype=\"multipart/form-data\"> Job Jar (*.jar) [Required]: <br/> <input type=\"file\" name=\"jar\"/> <br/> <br/> Config file (*.conf) [Optional]: <br/> <input type=\"file\" name=\"configfile\"/> <br/> <br/> Config String, Config File in string format. [Optional]: <br/> <input type=\"text\" name=\"configstring\" value=\"a.b.c.d=1\"/> <br/><br/> Executor count (integer, how many process to start for this streaming job) [Optional]: <br/> <input type=\"text\" name=\"executorcount\" value=\"1\"/> <br/><br/> Application arguments (String) [Optional]: <br/> <input type=\"text\" name=\"args\" value=\"\"/> <br/><br/> <input type=\"submit\" value=\"Submit\"/> </table> </form> POST api/v1.0/master/submitstormapp Submit a storm jar to Gearpump cluster. It functions like command line storm app -jar xx.jar -conf yy.yaml <command line arguments> Required MIME type: \"multipart/form-data\" Required post form fields: field name \"jar\", job jar file. Optional post form fields: \"configfile\", .yaml configuration file, in UTF8 format. \"args\", command line arguments for this job jar. Example html: <form id=\"submitstormapp\" action=\"http://127.0.0.1:8090/api/v1.0/master/submitstormapp\" method=\"POST\" enctype=\"multipart/form-data\"> Job Jar (*.jar) [Required]: <br/> <input type=\"file\" name=\"jar\"/> <br/> <br/> Config file (*.yaml) [Optional]: <br/> <input type=\"file\" name=\"configfile\"/> <br/> <br/> Application arguments (String) [Optional]: <br/> <input type=\"text\" name=\"args\" value=\"\"/> <br/><br/> <input type=\"submit\" value=\"Submit\"/> </table> </form> Worker service GET api/v1.0/worker/<workerId> Query worker information. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/worker/0 Sample Response: { \"workerId\": \"0\", \"state\": \"active\", \"actorPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker1\", \"aliveFor\": \"831069\", \"logFile\": \"logs/\", \"executors\": [ { \"appId\": 1, \"executorId\": 1, \"slots\": 1 } ], \"totalSlots\": 1000, \"availableSlots\": 999, \"homeDirectory\": \"/usr/lisa/gearpump/\", \"jvmName\": \"11788@lisa\" } GET api/v1.0/worker/<workerId>/config Query worker config Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/worker/0/config Sample Response: { \"extensions\": [ \"akka.contrib.datareplication.DataReplication$\" ] \"akka\": { \"loglevel\": \"INFO\" \"log-dead-letters\": \"off\" \"log-dead-letters-during-shutdown\": \"off\" \"actor\": { ## Master forms a akka cluster \"provider\": \"akka.cluster.ClusterActorRefProvider\" } \"cluster\": { \"roles\": [\"master\"] \"auto-down-unreachable-after\": \"15s\" } \"remote\": { \"log-remote-lifecycle-events\": \"off\" } } } GET api/v1.0/worker/<workerId>/metrics/<query_path>?readLatest=<true|false> Get the worker node metrics. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/worker/0/metrics/worker?readLatest=true Sample Response: { \"path\" : \"worker\", \"metrics\" : [{ \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.used\", \"value\": \"123139640\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.used\", \"value\": \"123139640\" } }] } Supervisor Service Supervisor service allows user to add or remove a worker machine. POST api/v1.0/supervisor/status Query whether the supervisor service is enabled. If Supervisor service is disabled, you are not allowed to use API like addworker/removeworker. Example: curl -X POST [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor/status Sample Response: {\"enabled\":true} GET api/v1.0/supervisor Get the supervisor path Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor Sample Response: {path: \"supervisor actor path\"} POST api/v1.0/supervisor/addworker/<worker-count> Add workerCount new workers in the cluster. It will use the low level resource scheduler like YARN to start new containers and then boot Gearpump worker process. Example: curl -X POST [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor/addworker/2 Sample Response: {success: true} POST api/v1.0/supervisor/removeworker/<worker-id> Remove single worker instance by specifying a worker Id. * NOTE: Use with caution! NOTE: All executors JVMs under this worker JVM will also be destroyed. It will trigger failover for all applications that have executor started under this worker. Example: curl -X POST [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor/removeworker/3 Sample Response: {success: true} Application service GET api/v1.0/appmaster/<appId>?detail=<true|false> Query information of an specific application of Id appId Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1?detail=true Sample Response: { \"appId\": 1, \"appName\": \"wordCount\", \"processors\": [ [ 0, { \"id\": 0, \"taskClass\": \"io.gearpump.streaming.examples.wordcount.Split\", \"parallelism\": 1, \"description\": \"\", \"taskConf\": { \"_config\": {} }, \"life\": { \"birth\": \"0\", \"death\": \"9223372036854775807\" }, \"executors\": [ 1 ], \"taskCount\": [ [ 1, { \"count\": 1 } ] ] } ], [ 1, { \"id\": 1, \"taskClass\": \"io.gearpump.streaming.examples.wordcount.Sum\", \"parallelism\": 1, \"description\": \"\", \"taskConf\": { \"_config\": {} }, \"life\": { \"birth\": \"0\", \"death\": \"9223372036854775807\" }, \"executors\": [ 0 ], \"taskCount\": [ [ 0, { \"count\": 1 } ] ] } ] ], \"processorLevels\": [ [ 0, 0 ], [ 1, 1 ] ], \"dag\": { \"vertexList\": [ 0, 1 ], \"edgeList\": [ [ 0, \"io.gearpump.partitioner.HashPartitioner\", 1 ] ] }, \"actorPath\": \"akka.tcp://app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster\", \"clock\": \"1450759382430\", \"executors\": [ { \"executorId\": 0, \"executor\": \"akka.tcp://app1system0@127.0.0.1:52240/remote/akka.tcp/app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster/executors/0#-1554950276\", \"workerId\": \"1\", \"status\": \"active\" }, { \"executorId\": 1, \"executor\": \"akka.tcp://app1system1@127.0.0.1:52241/remote/akka.tcp/app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster/executors/1#928082134\", \"workerId\": \"0\", \"status\": \"active\" }, { \"executorId\": -1, \"executor\": \"akka://app1-executor-1/user/daemon/appdaemon1/$c/appmaster\", \"workerId\": \"1\", \"status\": \"active\" } ], \"startTime\": \"1450758117306\", \"uptime\": \"1268472\", \"user\": \"lisa\", \"homeDirectory\": \"/usr/lisa/gearpump/\", \"logFile\": \"logs/\", \"historyMetricsConfig\": { \"retainHistoryDataHours\": 72, \"retainHistoryDataIntervalMs\": 3600000, \"retainRecentDataSeconds\": 300, \"retainRecentDataIntervalMs\": 15000 } } DELETE api/v1.0/appmaster/<appId> shutdown application appId GET api/v1.0/appmaster/<appId>/stallingtasks Query list of unhealthy tasks of an specific application of Id appId Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/2/stallingtasks Sample Response: { \"tasks\": [ { \"processorId\": 0, \"index\": 0 } ] } GET api/v1.0/appmaster/<appId>/config Query the configuration of specific application appId Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/config Sample Response: { \"gearpump\" : { \"appmaster\" : { \"extraClasspath\" : \"\", \"vmargs\" : \"-server -Xms512M -Xmx1024M -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3\" }, \"cluster\" : { \"masters\" : [ \"127.0.0.1:3000\" ] }, \"executor\" : { \"extraClasspath\" : \"\", \"vmargs\" : \"-server -Xms512M -Xmx1024M -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3\" }, \"jarstore\" : { \"rootpath\" : \"jarstore/\" }, \"log\" : { \"application\" : { \"dir\" : \"logs\" }, \"daemon\" : { \"dir\" : \"logs\" } }, \"metrics\" : { \"enabled\" : true, \"graphite\" : { \"host\" : \"127.0.0.1\", \"port\" : 2003 }, \"logfile\" : {}, \"report-interval-ms\" : 15000, \"reporter\" : \"akka\", \"retainHistoryData\" : { \"hours\" : 72, \"intervalMs\" : 3600000 }, \"retainRecentData\" : { \"intervalMs\" : 15000, \"seconds\" : 300 }, \"sample-rate\" : 10 }, \"netty\" : { \"base-sleep-ms\" : 100, \"buffer-size\" : 5242880, \"flush-check-interval\" : 10, \"max-retries\" : 30, \"max-sleep-ms\" : 1000, \"message-batch-size\" : 262144 }, \"netty-dispatcher\" : \"akka.actor.default-dispatcher\", \"scheduling\" : { \"scheduler-class\" : \"io.gearpump.cluster.scheduler.PriorityScheduler\" }, \"serializers\" : { \"[B\" : \"\", \"[C\" : \"\", \"[D\" : \"\", \"[F\" : \"\", \"[I\" : \"\", \"[J\" : \"\", \"[Ljava.lang.String;\" : \"\", \"[S\" : \"\", \"[Z\" : \"\", \"io.gearpump.Message\" : \"io.gearpump.streaming.MessageSerializer\", \"io.gearpump.streaming.task.Ack\" : \"io.gearpump.streaming.AckSerializer\", \"io.gearpump.streaming.task.AckRequest\" : \"io.gearpump.streaming.AckRequestSerializer\", \"io.gearpump.streaming.task.LatencyProbe\" : \"io.gearpump.streaming.LatencyProbeSerializer\", \"io.gearpump.streaming.task.TaskId\" : \"io.gearpump.streaming.TaskIdSerializer\", \"scala.Tuple1\" : \"\", \"scala.Tuple2\" : \"\", \"scala.Tuple3\" : \"\", \"scala.Tuple4\" : \"\", \"scala.Tuple5\" : \"\", \"scala.Tuple6\" : \"\", \"scala.collection.immutable.$colon$colon\" : \"\", \"scala.collection.immutable.List\" : \"\" }, \"services\" : { # gear.conf: 112 \"host\" : \"127.0.0.1\", # gear.conf: 113 \"http\" : 8090, # gear.conf: 114 \"ws\" : 8091 }, \"task-dispatcher\" : \"akka.actor.pined-dispatcher\", \"worker\" : { # reference.conf: 100 # # How many slots each worker contains \"slots\" : 100 } } } GET api/v1.0/appmaster/<appId>/metrics/<query_path>?readLatest=<true|false>&aggregator=<aggregator_class> Query metrics information of a specific application appId Filter metrics with path metrics path aggregator points to a aggregator class, which will aggregate on the current metrics, and return a smaller set. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/metrics/app1?readLatest=true&aggregator=io.gearpump.streaming.metrics.ProcessorAggregator Sample Response: { \"path\" : \"worker\", \"metrics\" : [{ \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.used\", \"value\": \"123139640\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.used\", \"value\": \"123139640\" } }] } GET api/v1.0/appmaster/<appId>/errors Get task error messages Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/errors Sample Response: {\"time\":\"0\",\"error\":null} POST api/v1.0/appmaster/<appId>/restart Restart the application Executor Service GET api/v1.0/appmaster/<appId>/executor/<executorid>/config Get executor config Example: curl http://127.0.0.1:8090/api/v1.0/appmaster/1/executor/1/config Sample Response: { \"extensions\": [ \"akka.contrib.datareplication.DataReplication$\" ] \"akka\": { \"loglevel\": \"INFO\" \"log-dead-letters\": \"off\" \"log-dead-letters-during-shutdown\": \"off\" \"actor\": { ## Master forms a akka cluster \"provider\": \"akka.cluster.ClusterActorRefProvider\" } \"cluster\": { \"roles\": [\"master\"] \"auto-down-unreachable-after\": \"15s\" } \"remote\": { \"log-remote-lifecycle-events\": \"off\" } } } GET api/v1.0/appmaster/<appId>/executor/<executorid> Get executor information. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/executor/1 Sample Response: { \"id\": 1, \"workerId\": \"0\", \"actorPath\": \"akka.tcp://app1system1@127.0.0.1:52241/remote/akka.tcp/app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster/executors/1\", \"logFile\": \"logs/\", \"status\": \"active\", \"taskCount\": 1, \"tasks\": [ [ 0, [ { \"processorId\": 0, \"index\": 0 } ] ] ], \"jvmName\": \"21304@lisa\" }","title":"REST API"},{"location":"dev/dev-rest-api.html#authentication","text":"For all REST API calls, We need authentication by default. If you don't want authentication, you can disable them.","title":"Authentication."},{"location":"dev/dev-rest-api.html#how-to-disable-authentication","text":"To disable Authentication, you can set gearpump-ui.gearpump.ui-security.authentication-enabled = false in gear.conf, please check UI Authentication for details.","title":"How to disable Authentication"},{"location":"dev/dev-rest-api.html#how-to-authenticate-if-authentication-is-enabled","text":"","title":"How to authenticate if Authentication is enabled."},{"location":"dev/dev-rest-api.html#for-user-password-based-authentication","text":"If Authentication is enabled, then you need to login before calling REST API. curl -X POST --data username=admin --data password=admin --cookie-jar outputAuthenticationCookie.txt http://127.0.0.1:8090/login This will use default user \"admin:admin\" to login, and store the authentication cookie to file outputAuthenticationCookie.txt. In All subsequent Rest API calls, you need to add the authentication cookie. For example curl --cookie outputAuthenticationCookie.txt http://127.0.0.1/api/v1.0/master for more information, please check UI Authentication .","title":"For User-Password based authentication"},{"location":"dev/dev-rest-api.html#for-oauth2-based-authentication","text":"For OAuth2 based authentication, it requires you to have an access token in place. Different OAuth2 service provider have different way to return an access token. For Google , you can refer to OAuth Doc . For CloudFoundry UAA , you can use the uaac command to get the access token. $ uaac target http://login.gearpump.gotapaas.eu/ $ uaac token get <user_email_address> ### Find access token $ uaac context [0]*[http://login.gearpump.gotapaas.eu] [0]*[<user_email_address>] user_id: 34e33a79-42c6-479b-a8c1-8c471ff027fb client_id: cf token_type: bearer access_token: eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiI expires_in: 599 scope: password.write openid cloud_controller.write cloud_controller.read jti: 74ea49e4-1001-4757-9f8d-a66e52a27557 For more information on uaac, please check UAAC guide Now, we have the access token, then let's login to Gearpump UI server with this access token: ## Please replace cloudfoundryuaa with actual OAuth2 service name you have configured in gear.conf curl -X POST --data accesstoken=eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiI --cookie-jar outputAuthenticationCookie.txt http://127.0.0.1:8090/login/oauth2/cloudfoundryuaa/accesstoken This will use user user_email_address to login, and store the authentication cookie to file outputAuthenticationCookie.txt. In All subsequent Rest API calls, you need to add the authentication cookie. For example curl --cookie outputAuthenticationCookie.txt http://127.0.0.1/api/v1.0/master NOTE: You can default the default permission level for OAuth2 user. for more information, please check UI Authentication .","title":"For OAuth2 based authentication"},{"location":"dev/dev-rest-api.html#query-version","text":"","title":"Query version"},{"location":"dev/dev-rest-api.html#get-version","text":"Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/version Sample Response: 0.9.0","title":"GET version"},{"location":"dev/dev-rest-api.html#master-service","text":"","title":"Master Service"},{"location":"dev/dev-rest-api.html#get-apiv10master","text":"Get information of masters Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master Sample Response: { \"masterDescription\": { \"leader\":{\"host\":\"master@127.0.0.1\",\"port\":3000}, \"cluster\":[{\"host\":\"127.0.0.1\",\"port\":3000}] \"aliveFor\": \"642941\", \"logFile\": \"/Users/foobar/gearpump/logs\", \"jarStore\": \"jarstore/\", \"masterStatus\": \"synced\", \"homeDirectory\": \"/Users/foobar/gearpump\" } }","title":"GET api/v1.0/master"},{"location":"dev/dev-rest-api.html#get-apiv10masterapplist","text":"Query information of all applications Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/applist Sample Response: { \"appMasters\": [ { \"status\": \"active\", \"appId\": 1, \"appName\": \"wordCount\", \"appMasterPath\": \"akka.tcp://app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c\", \"workerPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker0\", \"submissionTime\": \"1450758114766\", \"startTime\": \"1450758117294\", \"user\": \"lisa\" } ] }","title":"GET api/v1.0/master/applist"},{"location":"dev/dev-rest-api.html#get-apiv10masterworkerlist","text":"Query information of all workers Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/workerlist Sample Response: [ { \"workerId\": \"1\", \"state\": \"active\", \"actorPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker0\", \"aliveFor\": \"431565\", \"logFile\": \"logs/\", \"executors\": [ { \"appId\": 1, \"executorId\": -1, \"slots\": 1 }, { \"appId\": 1, \"executorId\": 0, \"slots\": 1 } ], \"totalSlots\": 1000, \"availableSlots\": 998, \"homeDirectory\": \"/usr/lisa/gearpump/\", \"jvmName\": \"11788@lisa\" }, { \"workerId\": \"0\", \"state\": \"active\", \"actorPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker1\", \"aliveFor\": \"431546\", \"logFile\": \"logs/\", \"executors\": [ { \"appId\": 1, \"executorId\": 1, \"slots\": 1 } ], \"totalSlots\": 1000, \"availableSlots\": 999, \"homeDirectory\": \"/usr/lisa/gearpump/\", \"jvmName\": \"11788@lisa\" } ]","title":"GET api/v1.0/master/workerlist"},{"location":"dev/dev-rest-api.html#get-apiv10masterconfig","text":"Get the configuration of all masters Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/config Sample Response: { \"extensions\": [ \"akka.contrib.datareplication.DataReplication$\" ] \"akka\": { \"loglevel\": \"INFO\" \"log-dead-letters\": \"off\" \"log-dead-letters-during-shutdown\": \"off\" \"actor\": { ## Master forms a akka cluster \"provider\": \"akka.cluster.ClusterActorRefProvider\" } \"cluster\": { \"roles\": [\"master\"] \"auto-down-unreachable-after\": \"15s\" } \"remote\": { \"log-remote-lifecycle-events\": \"off\" } } }","title":"GET api/v1.0/master/config"},{"location":"dev/dev-rest-api.html#get-apiv10mastermetricsquery_pathreadlatesttruefalse","text":"Get the master node metrics. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/master/metrics/master?readLatest=true Sample Response: { \"path\" : \"master\", \"metrics\" : [{ \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.heap.used\", \"value\": \"59764272\"} }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450758725070\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.total.max\", \"value\": \"997457920\"} }, { \"time\": \"1450758725070\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:memory.total.used\", \"value\": \"89117352\"} }, { \"time\": \"1450758725070\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"master:thread.count\", \"value\": \"28\"} }] }","title":"GET api/v1.0/master/metrics/&lt;query_path&gt;?readLatest=&lt;true|false&gt;"},{"location":"dev/dev-rest-api.html#post-apiv10mastersubmitapp","text":"Submit a streaming job jar to Gearpump cluster. It functions like command line gear app -jar xx.jar -conf yy.conf -executors 1 <command line arguments> Required MIME type: \"multipart/form-data\" Required post form fields: field name \"jar\", job jar file. Optional post form fields: \"configfile\", configuration file, in UTF8 format. \"configstring\", text body of configuration file, in UTF8 format. \"executorcount\", The count of JVM process to start across the cluster for this application job \"args\", command line arguments for this job jar. Example html: <form id=\"submitapp\" action=\"http://127.0.0.1:8090/api/v1.0/master/submitapp\" method=\"POST\" enctype=\"multipart/form-data\"> Job Jar (*.jar) [Required]: <br/> <input type=\"file\" name=\"jar\"/> <br/> <br/> Config file (*.conf) [Optional]: <br/> <input type=\"file\" name=\"configfile\"/> <br/> <br/> Config String, Config File in string format. [Optional]: <br/> <input type=\"text\" name=\"configstring\" value=\"a.b.c.d=1\"/> <br/><br/> Executor count (integer, how many process to start for this streaming job) [Optional]: <br/> <input type=\"text\" name=\"executorcount\" value=\"1\"/> <br/><br/> Application arguments (String) [Optional]: <br/> <input type=\"text\" name=\"args\" value=\"\"/> <br/><br/> <input type=\"submit\" value=\"Submit\"/> </table> </form>","title":"POST api/v1.0/master/submitapp"},{"location":"dev/dev-rest-api.html#post-apiv10mastersubmitstormapp","text":"Submit a storm jar to Gearpump cluster. It functions like command line storm app -jar xx.jar -conf yy.yaml <command line arguments> Required MIME type: \"multipart/form-data\" Required post form fields: field name \"jar\", job jar file. Optional post form fields: \"configfile\", .yaml configuration file, in UTF8 format. \"args\", command line arguments for this job jar. Example html: <form id=\"submitstormapp\" action=\"http://127.0.0.1:8090/api/v1.0/master/submitstormapp\" method=\"POST\" enctype=\"multipart/form-data\"> Job Jar (*.jar) [Required]: <br/> <input type=\"file\" name=\"jar\"/> <br/> <br/> Config file (*.yaml) [Optional]: <br/> <input type=\"file\" name=\"configfile\"/> <br/> <br/> Application arguments (String) [Optional]: <br/> <input type=\"text\" name=\"args\" value=\"\"/> <br/><br/> <input type=\"submit\" value=\"Submit\"/> </table> </form>","title":"POST api/v1.0/master/submitstormapp"},{"location":"dev/dev-rest-api.html#worker-service","text":"","title":"Worker service"},{"location":"dev/dev-rest-api.html#get-apiv10workerworkerid","text":"Query worker information. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/worker/0 Sample Response: { \"workerId\": \"0\", \"state\": \"active\", \"actorPath\": \"akka.tcp://master@127.0.0.1:3000/user/Worker1\", \"aliveFor\": \"831069\", \"logFile\": \"logs/\", \"executors\": [ { \"appId\": 1, \"executorId\": 1, \"slots\": 1 } ], \"totalSlots\": 1000, \"availableSlots\": 999, \"homeDirectory\": \"/usr/lisa/gearpump/\", \"jvmName\": \"11788@lisa\" }","title":"GET api/v1.0/worker/&lt;workerId&gt;"},{"location":"dev/dev-rest-api.html#get-apiv10workerworkeridconfig","text":"Query worker config Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/worker/0/config Sample Response: { \"extensions\": [ \"akka.contrib.datareplication.DataReplication$\" ] \"akka\": { \"loglevel\": \"INFO\" \"log-dead-letters\": \"off\" \"log-dead-letters-during-shutdown\": \"off\" \"actor\": { ## Master forms a akka cluster \"provider\": \"akka.cluster.ClusterActorRefProvider\" } \"cluster\": { \"roles\": [\"master\"] \"auto-down-unreachable-after\": \"15s\" } \"remote\": { \"log-remote-lifecycle-events\": \"off\" } } }","title":"GET api/v1.0/worker/&lt;workerId&gt;/config"},{"location":"dev/dev-rest-api.html#get-apiv10workerworkeridmetricsquery_pathreadlatesttruefalse","text":"Get the worker node metrics. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/worker/0/metrics/worker?readLatest=true Sample Response: { \"path\" : \"worker\", \"metrics\" : [{ \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.used\", \"value\": \"123139640\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.used\", \"value\": \"123139640\" } }] }","title":"GET api/v1.0/worker/&lt;workerId&gt;/metrics/&lt;query_path&gt;?readLatest=&lt;true|false&gt;"},{"location":"dev/dev-rest-api.html#supervisor-service","text":"Supervisor service allows user to add or remove a worker machine.","title":"Supervisor Service"},{"location":"dev/dev-rest-api.html#post-apiv10supervisorstatus","text":"Query whether the supervisor service is enabled. If Supervisor service is disabled, you are not allowed to use API like addworker/removeworker. Example: curl -X POST [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor/status Sample Response: {\"enabled\":true}","title":"POST api/v1.0/supervisor/status"},{"location":"dev/dev-rest-api.html#get-apiv10supervisor","text":"Get the supervisor path Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor Sample Response: {path: \"supervisor actor path\"}","title":"GET api/v1.0/supervisor"},{"location":"dev/dev-rest-api.html#post-apiv10supervisoraddworkerworker-count","text":"Add workerCount new workers in the cluster. It will use the low level resource scheduler like YARN to start new containers and then boot Gearpump worker process. Example: curl -X POST [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor/addworker/2 Sample Response: {success: true}","title":"POST api/v1.0/supervisor/addworker/&lt;worker-count&gt;"},{"location":"dev/dev-rest-api.html#post-apiv10supervisorremoveworkerworker-id","text":"Remove single worker instance by specifying a worker Id. * NOTE: Use with caution! NOTE: All executors JVMs under this worker JVM will also be destroyed. It will trigger failover for all applications that have executor started under this worker. Example: curl -X POST [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/supervisor/removeworker/3 Sample Response: {success: true}","title":"POST api/v1.0/supervisor/removeworker/&lt;worker-id&gt;"},{"location":"dev/dev-rest-api.html#application-service","text":"","title":"Application service"},{"location":"dev/dev-rest-api.html#get-apiv10appmasterappiddetailtruefalse","text":"Query information of an specific application of Id appId Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1?detail=true Sample Response: { \"appId\": 1, \"appName\": \"wordCount\", \"processors\": [ [ 0, { \"id\": 0, \"taskClass\": \"io.gearpump.streaming.examples.wordcount.Split\", \"parallelism\": 1, \"description\": \"\", \"taskConf\": { \"_config\": {} }, \"life\": { \"birth\": \"0\", \"death\": \"9223372036854775807\" }, \"executors\": [ 1 ], \"taskCount\": [ [ 1, { \"count\": 1 } ] ] } ], [ 1, { \"id\": 1, \"taskClass\": \"io.gearpump.streaming.examples.wordcount.Sum\", \"parallelism\": 1, \"description\": \"\", \"taskConf\": { \"_config\": {} }, \"life\": { \"birth\": \"0\", \"death\": \"9223372036854775807\" }, \"executors\": [ 0 ], \"taskCount\": [ [ 0, { \"count\": 1 } ] ] } ] ], \"processorLevels\": [ [ 0, 0 ], [ 1, 1 ] ], \"dag\": { \"vertexList\": [ 0, 1 ], \"edgeList\": [ [ 0, \"io.gearpump.partitioner.HashPartitioner\", 1 ] ] }, \"actorPath\": \"akka.tcp://app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster\", \"clock\": \"1450759382430\", \"executors\": [ { \"executorId\": 0, \"executor\": \"akka.tcp://app1system0@127.0.0.1:52240/remote/akka.tcp/app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster/executors/0#-1554950276\", \"workerId\": \"1\", \"status\": \"active\" }, { \"executorId\": 1, \"executor\": \"akka.tcp://app1system1@127.0.0.1:52241/remote/akka.tcp/app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster/executors/1#928082134\", \"workerId\": \"0\", \"status\": \"active\" }, { \"executorId\": -1, \"executor\": \"akka://app1-executor-1/user/daemon/appdaemon1/$c/appmaster\", \"workerId\": \"1\", \"status\": \"active\" } ], \"startTime\": \"1450758117306\", \"uptime\": \"1268472\", \"user\": \"lisa\", \"homeDirectory\": \"/usr/lisa/gearpump/\", \"logFile\": \"logs/\", \"historyMetricsConfig\": { \"retainHistoryDataHours\": 72, \"retainHistoryDataIntervalMs\": 3600000, \"retainRecentDataSeconds\": 300, \"retainRecentDataIntervalMs\": 15000 } }","title":"GET api/v1.0/appmaster/&lt;appId&gt;?detail=&lt;true|false&gt;"},{"location":"dev/dev-rest-api.html#delete-apiv10appmasterappid","text":"shutdown application appId","title":"DELETE api/v1.0/appmaster/&lt;appId&gt;"},{"location":"dev/dev-rest-api.html#get-apiv10appmasterappidstallingtasks","text":"Query list of unhealthy tasks of an specific application of Id appId Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/2/stallingtasks Sample Response: { \"tasks\": [ { \"processorId\": 0, \"index\": 0 } ] }","title":"GET api/v1.0/appmaster/&lt;appId&gt;/stallingtasks"},{"location":"dev/dev-rest-api.html#get-apiv10appmasterappidconfig","text":"Query the configuration of specific application appId Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/config Sample Response: { \"gearpump\" : { \"appmaster\" : { \"extraClasspath\" : \"\", \"vmargs\" : \"-server -Xms512M -Xmx1024M -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3\" }, \"cluster\" : { \"masters\" : [ \"127.0.0.1:3000\" ] }, \"executor\" : { \"extraClasspath\" : \"\", \"vmargs\" : \"-server -Xms512M -Xmx1024M -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3\" }, \"jarstore\" : { \"rootpath\" : \"jarstore/\" }, \"log\" : { \"application\" : { \"dir\" : \"logs\" }, \"daemon\" : { \"dir\" : \"logs\" } }, \"metrics\" : { \"enabled\" : true, \"graphite\" : { \"host\" : \"127.0.0.1\", \"port\" : 2003 }, \"logfile\" : {}, \"report-interval-ms\" : 15000, \"reporter\" : \"akka\", \"retainHistoryData\" : { \"hours\" : 72, \"intervalMs\" : 3600000 }, \"retainRecentData\" : { \"intervalMs\" : 15000, \"seconds\" : 300 }, \"sample-rate\" : 10 }, \"netty\" : { \"base-sleep-ms\" : 100, \"buffer-size\" : 5242880, \"flush-check-interval\" : 10, \"max-retries\" : 30, \"max-sleep-ms\" : 1000, \"message-batch-size\" : 262144 }, \"netty-dispatcher\" : \"akka.actor.default-dispatcher\", \"scheduling\" : { \"scheduler-class\" : \"io.gearpump.cluster.scheduler.PriorityScheduler\" }, \"serializers\" : { \"[B\" : \"\", \"[C\" : \"\", \"[D\" : \"\", \"[F\" : \"\", \"[I\" : \"\", \"[J\" : \"\", \"[Ljava.lang.String;\" : \"\", \"[S\" : \"\", \"[Z\" : \"\", \"io.gearpump.Message\" : \"io.gearpump.streaming.MessageSerializer\", \"io.gearpump.streaming.task.Ack\" : \"io.gearpump.streaming.AckSerializer\", \"io.gearpump.streaming.task.AckRequest\" : \"io.gearpump.streaming.AckRequestSerializer\", \"io.gearpump.streaming.task.LatencyProbe\" : \"io.gearpump.streaming.LatencyProbeSerializer\", \"io.gearpump.streaming.task.TaskId\" : \"io.gearpump.streaming.TaskIdSerializer\", \"scala.Tuple1\" : \"\", \"scala.Tuple2\" : \"\", \"scala.Tuple3\" : \"\", \"scala.Tuple4\" : \"\", \"scala.Tuple5\" : \"\", \"scala.Tuple6\" : \"\", \"scala.collection.immutable.$colon$colon\" : \"\", \"scala.collection.immutable.List\" : \"\" }, \"services\" : { # gear.conf: 112 \"host\" : \"127.0.0.1\", # gear.conf: 113 \"http\" : 8090, # gear.conf: 114 \"ws\" : 8091 }, \"task-dispatcher\" : \"akka.actor.pined-dispatcher\", \"worker\" : { # reference.conf: 100 # # How many slots each worker contains \"slots\" : 100 } } }","title":"GET api/v1.0/appmaster/&lt;appId&gt;/config"},{"location":"dev/dev-rest-api.html#get-apiv10appmasterappidmetricsquery_pathreadlatesttruefalseaggregatoraggregator_class","text":"Query metrics information of a specific application appId Filter metrics with path metrics path aggregator points to a aggregator class, which will aggregate on the current metrics, and return a smaller set. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/metrics/app1?readLatest=true&aggregator=io.gearpump.streaming.metrics.ProcessorAggregator Sample Response: { \"path\" : \"worker\", \"metrics\" : [{ \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.used\", \"value\": \"123139640\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.max\", \"value\": \"880017408\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:memory.total.used\", \"value\": \"152931440\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:thread.count\", \"value\": \"28\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.max\", \"value\": \"997457920\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.committed\", \"value\": \"179830784\" } }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.total.committed\", \"value\": \"210239488\" } }, { \"time\": \"1450759137860\", \"value\": {\"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker0:thread.daemon.count\", \"value\": \"18\"} }, { \"time\": \"1450759137860\", \"value\": { \"$type\": \"io.gearpump.metrics.Metrics.Gauge\", \"name\": \"worker1:memory.heap.used\", \"value\": \"123139640\" } }] }","title":"GET api/v1.0/appmaster/&lt;appId&gt;/metrics/&lt;query_path&gt;?readLatest=&lt;true|false&gt;&amp;aggregator=&lt;aggregator_class&gt;"},{"location":"dev/dev-rest-api.html#get-apiv10appmasterappiderrors","text":"Get task error messages Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/errors Sample Response: {\"time\":\"0\",\"error\":null}","title":"GET api/v1.0/appmaster/&lt;appId&gt;/errors"},{"location":"dev/dev-rest-api.html#post-apiv10appmasterappidrestart","text":"Restart the application","title":"POST api/v1.0/appmaster/&lt;appId&gt;/restart"},{"location":"dev/dev-rest-api.html#executor-service","text":"","title":"Executor Service"},{"location":"dev/dev-rest-api.html#get-apiv10appmasterappidexecutorexecutoridconfig","text":"Get executor config Example: curl http://127.0.0.1:8090/api/v1.0/appmaster/1/executor/1/config Sample Response: { \"extensions\": [ \"akka.contrib.datareplication.DataReplication$\" ] \"akka\": { \"loglevel\": \"INFO\" \"log-dead-letters\": \"off\" \"log-dead-letters-during-shutdown\": \"off\" \"actor\": { ## Master forms a akka cluster \"provider\": \"akka.cluster.ClusterActorRefProvider\" } \"cluster\": { \"roles\": [\"master\"] \"auto-down-unreachable-after\": \"15s\" } \"remote\": { \"log-remote-lifecycle-events\": \"off\" } } }","title":"GET api/v1.0/appmaster/&lt;appId&gt;/executor/&lt;executorid&gt;/config"},{"location":"dev/dev-rest-api.html#get-apiv10appmasterappidexecutorexecutorid","text":"Get executor information. Example: curl [--cookie outputAuthenticationCookie.txt] http://127.0.0.1:8090/api/v1.0/appmaster/1/executor/1 Sample Response: { \"id\": 1, \"workerId\": \"0\", \"actorPath\": \"akka.tcp://app1system1@127.0.0.1:52241/remote/akka.tcp/app1-executor-1@127.0.0.1:52212/user/daemon/appdaemon1/$c/appmaster/executors/1\", \"logFile\": \"logs/\", \"status\": \"active\", \"taskCount\": 1, \"tasks\": [ [ 0, [ { \"processorId\": 0, \"index\": 0 } ] ] ], \"jvmName\": \"21304@lisa\" }","title":"GET api/v1.0/appmaster/&lt;appId&gt;/executor/&lt;executorid&gt;"},{"location":"dev/dev-storm.html","text":"Gearpump provides binary compatibility for Apache Storm applications. That is to say, users could easily grab an existing Storm jar and run it on Gearpump. This documentation illustrates Gearpump's compatibility with Storm. What Storm features are supported on Gearpump Storm 0.9.x Feature Support basic topology yes DRPC yes multi-lang yes storm-kafka yes Trident no Storm 0.10.x Feature Support basic topology yes DRPC yes multi-lang yes storm-kafka yes storm-hdfs yes storm-hbase yes storm-hive yes storm-jdbc yes storm-redis yes flux yes storm-eventhubs not verified Trident no At Least Once support With Ackers enabled, there are two kinds of At Least Once support in both Storm 0.9.x and Storm 0.10.x. spout will replay messages on message loss as long as spout is alive If KafkaSpout is used, messages could be replayed from Kafka even if the spout crashes. Gearpump supports the second for both Storm versions. Security support Storm 0.10.x adds security support for following connectors storm-hdfs storm-hive storm-hbase That means users could access kerberos enabled HDFS, Hive and HBase with these connectors. Generally, Storm provides two approaches (please refer to above links for more information) configure nimbus to automatically get delegation tokens on behalf of the topology submitter user kerberos keytabs are already distributed on worker hosts; users configure keytab path and principal Gearpump supports the second approach and users needs to add classpath of HDFS/Hive/HBase to gearpump.executor.extraClasspath in gear.conf on each node. For example, ################### ### Executor argument configuration ### Executor JVM can contains multiple tasks ################### executor { vmargs = \"-server -Xms512M -Xmx1024M -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3 -Djava.rmi.server.hostname=localhost\" extraClasspath = \"/etc/hadoop/conf\" } How to run a Storm application on Gearpump This section shows how to run an existing Storm jar in a local Gearpump cluster. launch a local cluster bin/local start a Gearpump Nimbus server Users need server's address( nimbus.host and nimbus.thrift.port ) to submit topologies later. The address is written to a yaml config file set with -output option. Users can provide an existing config file where only the address will be overwritten. If not provided, a new file app.yaml is created with the config. bin/storm nimbus -output [conf <custom yaml config>] submit Storm applications Users can either submit Storm applications through command line or UI. a. submit Storm applications through command line bin/storm app -verbose -config app.yaml -jar storm-starter-${STORM_VERSION}.jar storm.starter.ExclamationTopology exclamation Users are able to configure their applications through following options jar - set the path of a Storm application jar config - submit the custom configuration file generated when launching Nimbus b. submit Storm application through UI Click on the \"Create\" button on the applications page on UI. Click on the \"Submit Storm Application\" item in the pull down menu. In the popup console, upload the Storm application jar and the configuration file generated when launching Nimbus, and fill in storm.starter.ExclamationTopology exclamation as arguments. Click on the \"Submit\" button Either way, check the dashboard and you should see data flowing through your topology. How is it different from running on Storm Topology submission When a client submits a Storm topology, Gearpump launches locally a simplified version of Storm's Nimbus server GearpumpNimbus . GearpumpNimbus then translates topology to a directed acyclic graph (DAG) of Gearpump, which is submitted to Gearpump master and deployed as a Gearpump application. GearpumpNimbus supports the following methods submitTopology / submitTopologyWithOpts killTopology / killTopologyWithOpts getTopology / getUserTopology getClusterInfo Topology translation Here's an example of WordCountTopology with acker bolts (ackers) being translated into a Gearpump DAG. Gearpump creates a StormProducer for each Storm spout and a StormProcessor for each Storm bolt (except for ackers) with the same parallelism, and wires them together using the same grouping strategy (partitioning in Gearpump) as in Storm. At runtime, spouts and bolts are running inside StormProducer tasks and StormProcessor tasks respectively. Messages emitted by spout are passed to StormProducer , transferred to StormProcessor and passed down to bolt. Messages are serialized / de-serialized with Storm serializers. Storm ackers are dropped since Gearpump has a different mechanism of message tracking and flow control. Task execution Each Storm task is executed by a dedicated thread while all Gearpump tasks of an executor share a thread pool. Generally, we can achieve better performance with a shared thread pool. It's possible, however, some tasks block and take up all the threads. In that case, we can fall back to the Storm way by setting gearpump.task-dispatcher to \"gearpump.single-thread-dispatcher\" in gear.conf . Message tracking Storm tracks the lineage of each message with ackers to guarantee at-least-once message delivery. Failed messages are re-sent from spout. Gearpump tracks messages between a sender and receiver in an efficient way . Message loss causes the whole application to replay from the minimum timestamp of all pending messages in the system . Flow control Storm throttles flow rate at spout, which stops sending messages if the number of unacked messages exceeds topology.max.spout.pending . Gearpump has flow control between tasks such that sender cannot flood receiver , which is backpressured till the source. Configurations All Storm configurations are respected with the following priority order defaults.yaml < custom file config < application config < component config where application config is submit from Storm application along with the topology component config is set in spout / bolt with getComponentConfiguration custom file config is specified with the -config option when submitting Storm application from command line or uploaded from UI StreamCQL Support StreamCQL is a Continuous Query Language on RealTime Computation System open sourced by Huawei. Since StreamCQL already supports Storm, it's straightforward to run StreamCQL over Gearpump. Install StreamCQL as in the official README Launch Gearpump Nimbus Server as before Go to the installed stream-cql-binary, and change following settings in conf/streaming-site.xml with the output Nimbus configs in Step 2. <property> <name>streaming.storm.nimbus.host</name> <value>${nimbus.host}</value> </property> <property> <name>streaming.storm.nimbus.port</name> <value>${nimbus.thrift.port}</value> </property> Open CQL client shell with bin/cql and execute a simple cql example Streaming> CREATE INPUT STREAM s (id INT, name STRING, type INT) SOURCE randomgen PROPERTIES ( timeUnit = \"SECONDS\", period = \"1\", eventNumPerperiod = \"1\", isSchedule = \"true\" ); CREATE OUTPUT STREAM rs (type INT, cc INT) SINK consoleOutput; INSERT INTO STREAM rs SELECT type, COUNT(id) as cc FROM s[RANGE 20 SECONDS BATCH] WHERE id > 5 GROUP BY type; SUBMIT APPLICATION example; Check the dashboard and you should see data flowing through a topology of 3 components.","title":"Storm Compatibility"},{"location":"dev/dev-storm.html#what-storm-features-are-supported-on-gearpump","text":"","title":"What Storm features are supported on Gearpump"},{"location":"dev/dev-storm.html#storm-09x","text":"Feature Support basic topology yes DRPC yes multi-lang yes storm-kafka yes Trident no","title":"Storm 0.9.x"},{"location":"dev/dev-storm.html#storm-010x","text":"Feature Support basic topology yes DRPC yes multi-lang yes storm-kafka yes storm-hdfs yes storm-hbase yes storm-hive yes storm-jdbc yes storm-redis yes flux yes storm-eventhubs not verified Trident no","title":"Storm 0.10.x"},{"location":"dev/dev-storm.html#at-least-once-support","text":"With Ackers enabled, there are two kinds of At Least Once support in both Storm 0.9.x and Storm 0.10.x. spout will replay messages on message loss as long as spout is alive If KafkaSpout is used, messages could be replayed from Kafka even if the spout crashes. Gearpump supports the second for both Storm versions.","title":"At Least Once support"},{"location":"dev/dev-storm.html#security-support","text":"Storm 0.10.x adds security support for following connectors storm-hdfs storm-hive storm-hbase That means users could access kerberos enabled HDFS, Hive and HBase with these connectors. Generally, Storm provides two approaches (please refer to above links for more information) configure nimbus to automatically get delegation tokens on behalf of the topology submitter user kerberos keytabs are already distributed on worker hosts; users configure keytab path and principal Gearpump supports the second approach and users needs to add classpath of HDFS/Hive/HBase to gearpump.executor.extraClasspath in gear.conf on each node. For example, ################### ### Executor argument configuration ### Executor JVM can contains multiple tasks ################### executor { vmargs = \"-server -Xms512M -Xmx1024M -Xss1M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC -XX:NewRatio=3 -Djava.rmi.server.hostname=localhost\" extraClasspath = \"/etc/hadoop/conf\" }","title":"Security support"},{"location":"dev/dev-storm.html#how-to-run-a-storm-application-on-gearpump","text":"This section shows how to run an existing Storm jar in a local Gearpump cluster. launch a local cluster bin/local start a Gearpump Nimbus server Users need server's address( nimbus.host and nimbus.thrift.port ) to submit topologies later. The address is written to a yaml config file set with -output option. Users can provide an existing config file where only the address will be overwritten. If not provided, a new file app.yaml is created with the config. bin/storm nimbus -output [conf <custom yaml config>] submit Storm applications Users can either submit Storm applications through command line or UI. a. submit Storm applications through command line bin/storm app -verbose -config app.yaml -jar storm-starter-${STORM_VERSION}.jar storm.starter.ExclamationTopology exclamation Users are able to configure their applications through following options jar - set the path of a Storm application jar config - submit the custom configuration file generated when launching Nimbus b. submit Storm application through UI Click on the \"Create\" button on the applications page on UI. Click on the \"Submit Storm Application\" item in the pull down menu. In the popup console, upload the Storm application jar and the configuration file generated when launching Nimbus, and fill in storm.starter.ExclamationTopology exclamation as arguments. Click on the \"Submit\" button Either way, check the dashboard and you should see data flowing through your topology.","title":"How to run a Storm application on Gearpump"},{"location":"dev/dev-storm.html#how-is-it-different-from-running-on-storm","text":"","title":"How is it different from running on Storm"},{"location":"dev/dev-storm.html#topology-submission","text":"When a client submits a Storm topology, Gearpump launches locally a simplified version of Storm's Nimbus server GearpumpNimbus . GearpumpNimbus then translates topology to a directed acyclic graph (DAG) of Gearpump, which is submitted to Gearpump master and deployed as a Gearpump application. GearpumpNimbus supports the following methods submitTopology / submitTopologyWithOpts killTopology / killTopologyWithOpts getTopology / getUserTopology getClusterInfo","title":"Topology submission"},{"location":"dev/dev-storm.html#topology-translation","text":"Here's an example of WordCountTopology with acker bolts (ackers) being translated into a Gearpump DAG. Gearpump creates a StormProducer for each Storm spout and a StormProcessor for each Storm bolt (except for ackers) with the same parallelism, and wires them together using the same grouping strategy (partitioning in Gearpump) as in Storm. At runtime, spouts and bolts are running inside StormProducer tasks and StormProcessor tasks respectively. Messages emitted by spout are passed to StormProducer , transferred to StormProcessor and passed down to bolt. Messages are serialized / de-serialized with Storm serializers. Storm ackers are dropped since Gearpump has a different mechanism of message tracking and flow control.","title":"Topology translation"},{"location":"dev/dev-storm.html#task-execution","text":"Each Storm task is executed by a dedicated thread while all Gearpump tasks of an executor share a thread pool. Generally, we can achieve better performance with a shared thread pool. It's possible, however, some tasks block and take up all the threads. In that case, we can fall back to the Storm way by setting gearpump.task-dispatcher to \"gearpump.single-thread-dispatcher\" in gear.conf .","title":"Task execution"},{"location":"dev/dev-storm.html#message-tracking","text":"Storm tracks the lineage of each message with ackers to guarantee at-least-once message delivery. Failed messages are re-sent from spout. Gearpump tracks messages between a sender and receiver in an efficient way . Message loss causes the whole application to replay from the minimum timestamp of all pending messages in the system .","title":"Message tracking"},{"location":"dev/dev-storm.html#flow-control","text":"Storm throttles flow rate at spout, which stops sending messages if the number of unacked messages exceeds topology.max.spout.pending . Gearpump has flow control between tasks such that sender cannot flood receiver , which is backpressured till the source.","title":"Flow control"},{"location":"dev/dev-storm.html#configurations","text":"All Storm configurations are respected with the following priority order defaults.yaml < custom file config < application config < component config where application config is submit from Storm application along with the topology component config is set in spout / bolt with getComponentConfiguration custom file config is specified with the -config option when submitting Storm application from command line or uploaded from UI","title":"Configurations"},{"location":"dev/dev-storm.html#streamcql-support","text":"StreamCQL is a Continuous Query Language on RealTime Computation System open sourced by Huawei. Since StreamCQL already supports Storm, it's straightforward to run StreamCQL over Gearpump. Install StreamCQL as in the official README Launch Gearpump Nimbus Server as before Go to the installed stream-cql-binary, and change following settings in conf/streaming-site.xml with the output Nimbus configs in Step 2. <property> <name>streaming.storm.nimbus.host</name> <value>${nimbus.host}</value> </property> <property> <name>streaming.storm.nimbus.port</name> <value>${nimbus.thrift.port}</value> </property> Open CQL client shell with bin/cql and execute a simple cql example Streaming> CREATE INPUT STREAM s (id INT, name STRING, type INT) SOURCE randomgen PROPERTIES ( timeUnit = \"SECONDS\", period = \"1\", eventNumPerperiod = \"1\", isSchedule = \"true\" ); CREATE OUTPUT STREAM rs (type INT, cc INT) SINK consoleOutput; INSERT INTO STREAM rs SELECT type, COUNT(id) as cc FROM s[RANGE 20 SECONDS BATCH] WHERE id > 5 GROUP BY type; SUBMIT APPLICATION example; Check the dashboard and you should see data flowing through a topology of 3 components.","title":"StreamCQL Support"},{"location":"dev/dev-write-1st-app.html","text":"Write your first Gearpump Application We'll use the classical wordcount example to illustrate how to write Gearpump applications. /** WordCount with High level DSL */ object WordCount extends AkkaApp with ArgumentsParser { override val options: Array[(String, CLIOption[Any])] = Array.empty override def main(akkaConf: Config, args: Array[String]): Unit = { val context = ClientContext(akkaConf) val app = StreamApp(\"dsl\", context) val data = \"This is a good start, bingo!! bingo!!\" //count for each word and output to log app.source(data.lines.toList, 1, \"source\"). // word => (word, count) flatMap(line => line.split(\"[\\\\s]+\")).map((_, 1)). // (word, count1), (word, count2) => (word, count1 + count2) groupByKey().sum.log context.submit(app).waitUntilFinish() context.close() } } The example is written in our Stream DSL , which provides you with convenient combinators (e.g. flatMap , groupByKey ) to easily write up transformations. IDE Setup (Optional) You can get your preferred IDE ready for Gearpump by following this guide . Submit application Finally, you need to package everything into a uber jar with proper dependencies and submit it to a Gearpump cluster. Please check out the application submission tool .","title":"Write Your 1st App"},{"location":"dev/dev-write-1st-app.html#write-your-first-gearpump-application","text":"We'll use the classical wordcount example to illustrate how to write Gearpump applications. /** WordCount with High level DSL */ object WordCount extends AkkaApp with ArgumentsParser { override val options: Array[(String, CLIOption[Any])] = Array.empty override def main(akkaConf: Config, args: Array[String]): Unit = { val context = ClientContext(akkaConf) val app = StreamApp(\"dsl\", context) val data = \"This is a good start, bingo!! bingo!!\" //count for each word and output to log app.source(data.lines.toList, 1, \"source\"). // word => (word, count) flatMap(line => line.split(\"[\\\\s]+\")).map((_, 1)). // (word, count1), (word, count2) => (word, count1 + count2) groupByKey().sum.log context.submit(app).waitUntilFinish() context.close() } } The example is written in our Stream DSL , which provides you with convenient combinators (e.g. flatMap , groupByKey ) to easily write up transformations.","title":"Write your first Gearpump Application"},{"location":"dev/dev-write-1st-app.html#ide-setup-optional","text":"You can get your preferred IDE ready for Gearpump by following this guide .","title":"IDE Setup (Optional)"},{"location":"dev/dev-write-1st-app.html#submit-application","text":"Finally, you need to package everything into a uber jar with proper dependencies and submit it to a Gearpump cluster. Please check out the application submission tool .","title":"Submit application"},{"location":"internals/gearpump-internals.html","text":"Actor Hierarchy? Everything in the diagram is an actor; they fall into two categories, Cluster Actors and Application Actors. Cluster Actors Worker : Maps to a physical worker machine. It is responsible for managing resources and report metrics on that machine. Master : Heart of the cluster, which manages workers, resources, and applications. The main function is delegated to three child actors, App Manager, Worker Manager, and Resource Scheduler. Application Actors: AppMaster : Responsible to schedule the tasks to workers and manage the state of the application. Different applications have different AppMaster instances and are isolated. Executor : Child of AppMaster, represents a JVM process. Its job is to manage the life cycle of tasks and recover the tasks in case of failure. Task : Child of Executor, does the real job. Every task actor has a global unique address. One task actor can send data to any other task actors. This gives us great flexibility of how the computation DAG is distributed. All actors in the graph are weaved together with actor supervision, and actor watching and every error is handled properly via supervisors. In a master, a risky job is isolated and delegated to child actors, so it's more robust. In the application, an extra intermediate layer \"Executor\" is created so that we can do fine-grained and fast recovery in case of task failure. A master watches the lifecycle of AppMaster and worker to handle the failures, but the life cycle of Worker and AppMaster are not bound to a Master Actor by supervision, so that Master node can fail independently. Several Master Actors form an Akka cluster, the Master state is exchanged using the Gossip protocol in a conflict-free consistent way so that there is no single point of failure. With this hierarchy design, we are able to achieve high availability. Application Clock and Global Clock Service Global clock service will track the minimum time stamp of all pending messages in the system. Every task will update its own minimum-clock to global clock service; the minimum-clock of task is decided by the minimum of: Minimum time stamp of all pending messages in the inbox. Minimum time stamp of all un-acked outgoing messages. When there is message loss, the minimum clock will not advance. Minimum clock of all task states. If the state is accumulated by a lot of input messages, then the clock value is decided by the oldest message's timestamp. The state clock will advance by doing snapshots to persistent storage or by fading out the effect of old messages. The global clock service will keep track of all task minimum clocks effectively and maintain a global view of minimum clock. The global minimum clock value is monotonically increasing; it means that all source messages before this clock value have been processed. If there is message loss or task crash, the global minimum clock will stop. How do we optimize the message passing performance? For streaming application, message passing performance is extremely important. For example, one streaming platform may need to process millions of messages per second with millisecond level latency. High throughput and low latency is not that easy to achieve. There are a number of challenges: First Challenge: Network is not efficient for small messages In streaming, typical message size is very small, usually less than 100 bytes per message, like the floating car GPS data. But network efficiency is very bad when transferring small messages. As you can see in below diagram, when message size is 50 bytes, it can only use 20% bandwidth. How to improve the throughput? Second Challenge: Message overhead is too big For each message sent between two actors, it contains sender and receiver actor path. When sending over the wire, the overhead of this ActorPath is not trivial. For example, the below actor path takes more than 200 bytes. akka.tcp://system1@192.168.1.53:51582/remote/akka.tcp/2120193a-e10b-474e-bccb-8ebc4b3a0247@192.168.1.53:48948/remote/akka.tcp/system2@192.168.1.54:43676/user/master/Worker1/app_0_executor_0/group_1_task_0#-768886794 How do we solve this? We implement a custom Netty transportation layer with Akka extension. In the below diagram, Netty Client will translate ActorPath to TaskId, and Netty Server will translate it back. Only TaskId will be passed on wire, it is only about 10 bytes, the overhead is minimized. Different Netty Client Actors are isolated; they will not block each other. For performance, effective batching is really the key! We group multiple messages to a single batch and send it on the wire. The batch size is not fixed; it is adjusted dynamically based on network status. If the network is available, we will flush pending messages immediately without waiting; otherwise we will put the message in a batch and trigger a timer to flush the batch later. How do we do flow Control? Without flow control, one task can easily flood another task with too many messages, causing out of memory error. Typical flow control will use a TCP-like sliding window, so that source and target can run concurrently without blocking each other. Figure: Flow control, each task is \"star\" connected to input tasks and output tasks The difficult part for our problem is that each task can have multiple input tasks and output tasks. The input and output must be geared together so that the back pressure can be properly propagated from downstream to upstream. The flow control also needs to consider failures, and it needs to be able to recover when there is message loss. Another challenge is that the overhead of flow control messages can be big. If we ack every message, there will be huge amount of acked messages in the system, degrading streaming performance. The approach we adopted is to use explicit AckRequest message. The target tasks will only ack back when they receive the AckRequest message, and the source will only send AckRequest when it feels necessary. With this approach, we can largely reduce the overhead. How do we detect message loss? For example, for web ads, we may charge for every click, we don't want to miscount. The streaming platform needs to effectively track what messages have been lost, and recover as fast as possible. Figure: Message Loss Detection We use the flow control message AckRequest and Ack to detect message loss. The target task will count how many messages has been received since last AckRequest, and ack the count back to source task. The source task will check the count and find message loss. This is just an illustration, the real case is more difficulty, we need to handle zombie tasks, and in-the-fly stale messages. How Gearpump know what messages to replay? In some applications, a message cannot be lost, and must be replayed. For example, during the money transfer, the bank will SMS us the verification code. If that message is lost, the system must replay it so that money transfer can continue. We made the decision to use source end message storage and time stamp based replay . Figure: Replay with Source End Message Store Every message is immutable, and tagged with a timestamp. We have an assumption that the timestamp is approximately incremental (allow small ratio message disorder). We assume the message is coming from a replay-able source, like Kafka queue; otherwise the message will be stored at customizable source end \"message store\". When the source task sends the message downstream, the timestamp and offset of the message is also check-pointed to offset-timestamp storage periodically. During recovery, the system will first retrieve the right time stamp and offset from the offset-timestamp storage, then it will replay the message store from that time stamp and offset. A Timestamp Filter will filter out old messages in case the message in message store is not strictly time-ordered. Master High Availability In a distributed streaming system, any part can fail. The system must stay responsive and do recovery in case of errors. Figure: Master High Availability We use Akka clustering to implement the Master high availability. The cluster consists of several master nodes, but no worker nodes. With clustering facilities, we can easily detect and handle the failure of master node crash. The master state is replicated on all master nodes with the Typesafe akka-data-replication library, when one master node crashes, another standby master will read the master state and take over. The master state contains the submission data of all applications. If one application dies, a master can use that state to recover that application. CRDT LwwMap is used to represent the state; it is a hash map that can converge on distributed nodes without conflict. To have strong data consistency, the state read and write must happen on a quorum of master nodes. How we do handle failures? With Akka's powerful actor supervision, we can implement a resilient system relatively easy. In Gearpump, different applications have a different AppMaster instance, they are totally isolated from each other. For each application, there is a supervision tree, AppMaster->Executor->Task. With this supervision hierarchy, we can free ourselves from the headache of zombie process, for example if AppMaster is down, Akka supervisor will ensure the whole tree is shutting down. There are multiple possible failure scenarios Figure: Possible Failure Scenarios and Error Supervision Hierarchy What happens when the Master crashes? In case of a master crash, other standby masters will be notified, they will resume the master state, and take over control. Worker and AppMaster will also be notified, They will trigger a process to find the new active master, until the resolution complete. If AppMaster or Worker cannot resolve a new Master in a time out, they will make suicide and kill themselves. What happens when a worker crashes? In case of a worker crash, the Master will get notified and stop scheduling new computation to this worker. All supervised executors on current worker will be killed, AppMaster can treat it as recovery of executor crash like What happen when an executor crashes? What happens when the AppMaster crashes? If an AppMaster crashes, Master will schedule a new resource to create a new AppMaster Instance elsewhere, and then the AppMaster will handle the recovery inside the application. For streaming, it will recover the latest min clock and other state from disk, request resources from master to start executors, and restart the tasks with recovered min clock. What happen when an executor crashes? If an executor crashes, its supervisor AppMaster will get notified, and request a new resource from the active master to start a new executor, to run the tasks which were located on the crashed executor. What happen when tasks crash? If a task throws an exception, its supervisor executor will restart that Task. When \"at least once\" message delivery is enabled, it will trigger the message replaying in the case of message loss. First AppMaster will read the latest minimum clock from the global clock service(or clock storage if the clock service crashes), then AppMaster will restart all the task actors to get a fresh task state, then the source end tasks will replay messages from that minimum clock. How does \"exactly-once\" message delivery work? For some applications, it is extremely important to do \"exactly once\" message delivery. For example, for a real-time billing system, we will not want to bill the customer twice. The goal of \"exactly once\" message delivery is to make sure: The error doesn't accumulate, today's error will not be accumulated to tomorrow. Transparent to application developer We use global clock to synchronize the distributed transactions. We assume every message from the data source will have a unique timestamp, the timestamp can be a part of the message body, or can be attached later with system clock when the message is injected into the streaming system. With this global synchronized clock, we can coordinate all tasks to checkpoint at same timestamp. Figure: Checkpointing and Exactly-Once Message delivery Workflow to do state checkpointing: The coordinator asks the streaming system to do checkpoint at timestamp Tc. For each application task, it will maintain two states, checkpoint state and current state. Checkpoint state only contains information before timestamp Tc. Current state contains all information. When global minimum clock is larger than Tc, it means all messages older than Tc has been processed; the checkpoint state will no longer change, so we will then persist the checkpoint state to storage safely. When there is message loss, we will start the recovery process. To recover, load the latest checkpoint state from store, and then use it to restore the application status. Data source replays messages from the checkpoint timestamp. The checkpoint interval is determined by global clock service dynamically. Each data source will track the max timestamp of input messages. Upon receiving min clock updates, the data source will report the time delta back to global clock service. The max time delta is the upper bound of the application state timespan. The checkpoint interval is bigger than max delta time: Figure: How to determine Checkpoint Interval After the checkpoint interval is notified to tasks by global clock service, each task will calculate its next checkpoint timestamp autonomously without global synchronization. For each task, it contains two states, checkpoint state and current state. The code to update the state is shown in listing below. TaskState(stateStore, initialTimeStamp): currentState = stateStore.load(initialTimeStamp) checkpointState = currentState.clone checkpointTimestamp = nextCheckpointTimeStamp(initialTimeStamp) onMessage(msg): if (msg.timestamp < checkpointTimestamp): checkpointState.updateMessage(msg) currentState.updateMessage(msg) maxClock = max(maxClock, msg.timeStamp) onMinClock(minClock): if (minClock > checkpointTimestamp): stateStore.persist(checkpointState) checkpointTimeStamp = nextCheckpointTimeStamp(maxClock) checkpointState = currentState.clone onNewCheckpointInterval(newStep): step = newStep nextCheckpointTimeStamp(timestamp): checkpointTimestamp = (1 + timestamp/step) * step List 1: Task Transactional State Implementation What is dynamic graph, and how it works? The DAG can be modified dynamically. We want to be able to dynamically add, remove, and replace a sub-graph. Figure: Dynamic Graph, Attach, Replace, and Remove At least once message delivery and Kafka The Kafka source example project and tutorials can be found at: - Kafka connector example project - Connect with Kafka source In this doc, we will talk about how the at least once message delivery works. We will use the WordCount example of source tree to illustrate. How the kafka WordCount DAG looks like: It contains three processors: KafkaStreamProducer(or KafkaSource) will read message from kafka queue. Split will split lines to words Sum will summarize the words to get a count for each word. How to read data from Kafka We use KafkaSource, please check Connect with Kafka source for the introduction. Please note that we have set a startTimestamp for the KafkaSource, which means KafkaSource will read from Kafka queue starting from messages whose timestamp is near startTimestamp. What happen where there is Task crash or message loss? When there is message loss, the AppMaster will first pause the global clock service so that the global minimum timestamp no longer change, then it will restart the Kafka source tasks. Upon restart, Kafka Source will start to replay. It will first read the global minimum timestamp from AppMaster, and start to read message from that timestamp. What method KafkaSource used to read messages from a start timestamp? As we know Kafka queue doesn't expose the timestamp information. Kafka queue only expose the offset information for each partition. What KafkaSource do is to maintain its own mapping from Kafka offset to Application timestamp, so that we can map from a application timestamp to a Kafka offset, and replay Kafka messages from that Kafka offset. The mapping between Application timestamp with Kafka offset is stored in a distributed file system or as a Kafka topic.","title":"Gearpump Internals"},{"location":"internals/gearpump-internals.html#actor-hierarchy","text":"Everything in the diagram is an actor; they fall into two categories, Cluster Actors and Application Actors.","title":"Actor Hierarchy?"},{"location":"internals/gearpump-internals.html#cluster-actors","text":"Worker : Maps to a physical worker machine. It is responsible for managing resources and report metrics on that machine. Master : Heart of the cluster, which manages workers, resources, and applications. The main function is delegated to three child actors, App Manager, Worker Manager, and Resource Scheduler.","title":"Cluster Actors"},{"location":"internals/gearpump-internals.html#application-actors","text":"AppMaster : Responsible to schedule the tasks to workers and manage the state of the application. Different applications have different AppMaster instances and are isolated. Executor : Child of AppMaster, represents a JVM process. Its job is to manage the life cycle of tasks and recover the tasks in case of failure. Task : Child of Executor, does the real job. Every task actor has a global unique address. One task actor can send data to any other task actors. This gives us great flexibility of how the computation DAG is distributed. All actors in the graph are weaved together with actor supervision, and actor watching and every error is handled properly via supervisors. In a master, a risky job is isolated and delegated to child actors, so it's more robust. In the application, an extra intermediate layer \"Executor\" is created so that we can do fine-grained and fast recovery in case of task failure. A master watches the lifecycle of AppMaster and worker to handle the failures, but the life cycle of Worker and AppMaster are not bound to a Master Actor by supervision, so that Master node can fail independently. Several Master Actors form an Akka cluster, the Master state is exchanged using the Gossip protocol in a conflict-free consistent way so that there is no single point of failure. With this hierarchy design, we are able to achieve high availability.","title":"Application Actors:"},{"location":"internals/gearpump-internals.html#application-clock-and-global-clock-service","text":"Global clock service will track the minimum time stamp of all pending messages in the system. Every task will update its own minimum-clock to global clock service; the minimum-clock of task is decided by the minimum of: Minimum time stamp of all pending messages in the inbox. Minimum time stamp of all un-acked outgoing messages. When there is message loss, the minimum clock will not advance. Minimum clock of all task states. If the state is accumulated by a lot of input messages, then the clock value is decided by the oldest message's timestamp. The state clock will advance by doing snapshots to persistent storage or by fading out the effect of old messages. The global clock service will keep track of all task minimum clocks effectively and maintain a global view of minimum clock. The global minimum clock value is monotonically increasing; it means that all source messages before this clock value have been processed. If there is message loss or task crash, the global minimum clock will stop.","title":"Application Clock and Global Clock Service"},{"location":"internals/gearpump-internals.html#how-do-we-optimize-the-message-passing-performance","text":"For streaming application, message passing performance is extremely important. For example, one streaming platform may need to process millions of messages per second with millisecond level latency. High throughput and low latency is not that easy to achieve. There are a number of challenges:","title":"How do we optimize the message passing performance?"},{"location":"internals/gearpump-internals.html#first-challenge-network-is-not-efficient-for-small-messages","text":"In streaming, typical message size is very small, usually less than 100 bytes per message, like the floating car GPS data. But network efficiency is very bad when transferring small messages. As you can see in below diagram, when message size is 50 bytes, it can only use 20% bandwidth. How to improve the throughput?","title":"First Challenge: Network is not efficient for small messages"},{"location":"internals/gearpump-internals.html#second-challenge-message-overhead-is-too-big","text":"For each message sent between two actors, it contains sender and receiver actor path. When sending over the wire, the overhead of this ActorPath is not trivial. For example, the below actor path takes more than 200 bytes. akka.tcp://system1@192.168.1.53:51582/remote/akka.tcp/2120193a-e10b-474e-bccb-8ebc4b3a0247@192.168.1.53:48948/remote/akka.tcp/system2@192.168.1.54:43676/user/master/Worker1/app_0_executor_0/group_1_task_0#-768886794","title":"Second Challenge: Message overhead is too big"},{"location":"internals/gearpump-internals.html#how-do-we-solve-this","text":"We implement a custom Netty transportation layer with Akka extension. In the below diagram, Netty Client will translate ActorPath to TaskId, and Netty Server will translate it back. Only TaskId will be passed on wire, it is only about 10 bytes, the overhead is minimized. Different Netty Client Actors are isolated; they will not block each other. For performance, effective batching is really the key! We group multiple messages to a single batch and send it on the wire. The batch size is not fixed; it is adjusted dynamically based on network status. If the network is available, we will flush pending messages immediately without waiting; otherwise we will put the message in a batch and trigger a timer to flush the batch later.","title":"How do we solve this?"},{"location":"internals/gearpump-internals.html#how-do-we-do-flow-control","text":"Without flow control, one task can easily flood another task with too many messages, causing out of memory error. Typical flow control will use a TCP-like sliding window, so that source and target can run concurrently without blocking each other. Figure: Flow control, each task is \"star\" connected to input tasks and output tasks The difficult part for our problem is that each task can have multiple input tasks and output tasks. The input and output must be geared together so that the back pressure can be properly propagated from downstream to upstream. The flow control also needs to consider failures, and it needs to be able to recover when there is message loss. Another challenge is that the overhead of flow control messages can be big. If we ack every message, there will be huge amount of acked messages in the system, degrading streaming performance. The approach we adopted is to use explicit AckRequest message. The target tasks will only ack back when they receive the AckRequest message, and the source will only send AckRequest when it feels necessary. With this approach, we can largely reduce the overhead.","title":"How do we do flow Control?"},{"location":"internals/gearpump-internals.html#how-do-we-detect-message-loss","text":"For example, for web ads, we may charge for every click, we don't want to miscount. The streaming platform needs to effectively track what messages have been lost, and recover as fast as possible. Figure: Message Loss Detection We use the flow control message AckRequest and Ack to detect message loss. The target task will count how many messages has been received since last AckRequest, and ack the count back to source task. The source task will check the count and find message loss. This is just an illustration, the real case is more difficulty, we need to handle zombie tasks, and in-the-fly stale messages.","title":"How do we detect message loss?"},{"location":"internals/gearpump-internals.html#how-gearpump-know-what-messages-to-replay","text":"In some applications, a message cannot be lost, and must be replayed. For example, during the money transfer, the bank will SMS us the verification code. If that message is lost, the system must replay it so that money transfer can continue. We made the decision to use source end message storage and time stamp based replay . Figure: Replay with Source End Message Store Every message is immutable, and tagged with a timestamp. We have an assumption that the timestamp is approximately incremental (allow small ratio message disorder). We assume the message is coming from a replay-able source, like Kafka queue; otherwise the message will be stored at customizable source end \"message store\". When the source task sends the message downstream, the timestamp and offset of the message is also check-pointed to offset-timestamp storage periodically. During recovery, the system will first retrieve the right time stamp and offset from the offset-timestamp storage, then it will replay the message store from that time stamp and offset. A Timestamp Filter will filter out old messages in case the message in message store is not strictly time-ordered.","title":"How Gearpump know what messages to replay?"},{"location":"internals/gearpump-internals.html#master-high-availability","text":"In a distributed streaming system, any part can fail. The system must stay responsive and do recovery in case of errors. Figure: Master High Availability We use Akka clustering to implement the Master high availability. The cluster consists of several master nodes, but no worker nodes. With clustering facilities, we can easily detect and handle the failure of master node crash. The master state is replicated on all master nodes with the Typesafe akka-data-replication library, when one master node crashes, another standby master will read the master state and take over. The master state contains the submission data of all applications. If one application dies, a master can use that state to recover that application. CRDT LwwMap is used to represent the state; it is a hash map that can converge on distributed nodes without conflict. To have strong data consistency, the state read and write must happen on a quorum of master nodes.","title":"Master High Availability"},{"location":"internals/gearpump-internals.html#how-we-do-handle-failures","text":"With Akka's powerful actor supervision, we can implement a resilient system relatively easy. In Gearpump, different applications have a different AppMaster instance, they are totally isolated from each other. For each application, there is a supervision tree, AppMaster->Executor->Task. With this supervision hierarchy, we can free ourselves from the headache of zombie process, for example if AppMaster is down, Akka supervisor will ensure the whole tree is shutting down. There are multiple possible failure scenarios Figure: Possible Failure Scenarios and Error Supervision Hierarchy","title":"How we do handle failures?"},{"location":"internals/gearpump-internals.html#what-happens-when-the-master-crashes","text":"In case of a master crash, other standby masters will be notified, they will resume the master state, and take over control. Worker and AppMaster will also be notified, They will trigger a process to find the new active master, until the resolution complete. If AppMaster or Worker cannot resolve a new Master in a time out, they will make suicide and kill themselves.","title":"What happens when the Master crashes?"},{"location":"internals/gearpump-internals.html#what-happens-when-a-worker-crashes","text":"In case of a worker crash, the Master will get notified and stop scheduling new computation to this worker. All supervised executors on current worker will be killed, AppMaster can treat it as recovery of executor crash like What happen when an executor crashes?","title":"What happens when a worker crashes?"},{"location":"internals/gearpump-internals.html#what-happens-when-the-appmaster-crashes","text":"If an AppMaster crashes, Master will schedule a new resource to create a new AppMaster Instance elsewhere, and then the AppMaster will handle the recovery inside the application. For streaming, it will recover the latest min clock and other state from disk, request resources from master to start executors, and restart the tasks with recovered min clock.","title":"What happens when the AppMaster crashes?"},{"location":"internals/gearpump-internals.html#what-happen-when-an-executor-crashes","text":"If an executor crashes, its supervisor AppMaster will get notified, and request a new resource from the active master to start a new executor, to run the tasks which were located on the crashed executor.","title":"What happen when an executor crashes?"},{"location":"internals/gearpump-internals.html#what-happen-when-tasks-crash","text":"If a task throws an exception, its supervisor executor will restart that Task. When \"at least once\" message delivery is enabled, it will trigger the message replaying in the case of message loss. First AppMaster will read the latest minimum clock from the global clock service(or clock storage if the clock service crashes), then AppMaster will restart all the task actors to get a fresh task state, then the source end tasks will replay messages from that minimum clock.","title":"What happen when tasks crash?"},{"location":"internals/gearpump-internals.html#how-does-exactly-once-message-delivery-work","text":"For some applications, it is extremely important to do \"exactly once\" message delivery. For example, for a real-time billing system, we will not want to bill the customer twice. The goal of \"exactly once\" message delivery is to make sure: The error doesn't accumulate, today's error will not be accumulated to tomorrow. Transparent to application developer We use global clock to synchronize the distributed transactions. We assume every message from the data source will have a unique timestamp, the timestamp can be a part of the message body, or can be attached later with system clock when the message is injected into the streaming system. With this global synchronized clock, we can coordinate all tasks to checkpoint at same timestamp. Figure: Checkpointing and Exactly-Once Message delivery Workflow to do state checkpointing: The coordinator asks the streaming system to do checkpoint at timestamp Tc. For each application task, it will maintain two states, checkpoint state and current state. Checkpoint state only contains information before timestamp Tc. Current state contains all information. When global minimum clock is larger than Tc, it means all messages older than Tc has been processed; the checkpoint state will no longer change, so we will then persist the checkpoint state to storage safely. When there is message loss, we will start the recovery process. To recover, load the latest checkpoint state from store, and then use it to restore the application status. Data source replays messages from the checkpoint timestamp. The checkpoint interval is determined by global clock service dynamically. Each data source will track the max timestamp of input messages. Upon receiving min clock updates, the data source will report the time delta back to global clock service. The max time delta is the upper bound of the application state timespan. The checkpoint interval is bigger than max delta time: Figure: How to determine Checkpoint Interval After the checkpoint interval is notified to tasks by global clock service, each task will calculate its next checkpoint timestamp autonomously without global synchronization. For each task, it contains two states, checkpoint state and current state. The code to update the state is shown in listing below. TaskState(stateStore, initialTimeStamp): currentState = stateStore.load(initialTimeStamp) checkpointState = currentState.clone checkpointTimestamp = nextCheckpointTimeStamp(initialTimeStamp) onMessage(msg): if (msg.timestamp < checkpointTimestamp): checkpointState.updateMessage(msg) currentState.updateMessage(msg) maxClock = max(maxClock, msg.timeStamp) onMinClock(minClock): if (minClock > checkpointTimestamp): stateStore.persist(checkpointState) checkpointTimeStamp = nextCheckpointTimeStamp(maxClock) checkpointState = currentState.clone onNewCheckpointInterval(newStep): step = newStep nextCheckpointTimeStamp(timestamp): checkpointTimestamp = (1 + timestamp/step) * step List 1: Task Transactional State Implementation","title":"How does \"exactly-once\" message delivery work?"},{"location":"internals/gearpump-internals.html#what-is-dynamic-graph-and-how-it-works","text":"The DAG can be modified dynamically. We want to be able to dynamically add, remove, and replace a sub-graph. Figure: Dynamic Graph, Attach, Replace, and Remove","title":"What is dynamic graph, and how it works?"},{"location":"internals/gearpump-internals.html#at-least-once-message-delivery-and-kafka","text":"The Kafka source example project and tutorials can be found at: - Kafka connector example project - Connect with Kafka source In this doc, we will talk about how the at least once message delivery works. We will use the WordCount example of source tree to illustrate.","title":"At least once message delivery and Kafka"},{"location":"internals/gearpump-internals.html#how-the-kafka-wordcount-dag-looks-like","text":"It contains three processors: KafkaStreamProducer(or KafkaSource) will read message from kafka queue. Split will split lines to words Sum will summarize the words to get a count for each word.","title":"How the kafka WordCount DAG looks like:"},{"location":"internals/gearpump-internals.html#how-to-read-data-from-kafka","text":"We use KafkaSource, please check Connect with Kafka source for the introduction. Please note that we have set a startTimestamp for the KafkaSource, which means KafkaSource will read from Kafka queue starting from messages whose timestamp is near startTimestamp.","title":"How to read data from Kafka"},{"location":"internals/gearpump-internals.html#what-happen-where-there-is-task-crash-or-message-loss","text":"When there is message loss, the AppMaster will first pause the global clock service so that the global minimum timestamp no longer change, then it will restart the Kafka source tasks. Upon restart, Kafka Source will start to replay. It will first read the global minimum timestamp from AppMaster, and start to read message from that timestamp.","title":"What happen where there is Task crash or message loss?"},{"location":"internals/gearpump-internals.html#what-method-kafkasource-used-to-read-messages-from-a-start-timestamp-as-we-know-kafka-queue-doesnt-expose-the-timestamp-information","text":"Kafka queue only expose the offset information for each partition. What KafkaSource do is to maintain its own mapping from Kafka offset to Application timestamp, so that we can map from a application timestamp to a Kafka offset, and replay Kafka messages from that Kafka offset. The mapping between Application timestamp with Kafka offset is stored in a distributed file system or as a Kafka topic.","title":"What method KafkaSource used to read messages from a start timestamp? As we know Kafka queue doesn't expose the timestamp information."},{"location":"introduction/basic-concepts.html","text":"System timestamp and Application timestamp System timestamp denotes the time of backend cluster system. Application timestamp denotes the time at which message is generated. For example, for IoT edge device, the timestamp at which field sensor device creates a message is type of application timestamp, while the timestamp at which that message get received by the backend is type of system time. Master, and Worker Gearpump follow master slave architecture. Every cluster contains one or more Master node, and several worker nodes. Worker node is responsible to manage local resources on single machine, and Master node is responsible to manage global resources of the whole cluster. Application Application is what we want to parallel and run on the cluster. There are different application types, for example MapReduce application and streaming application are different application types. Gearpump natively supports Streaming Application types, it also contains several templates to help user to create custom application types, like distributedShell. AppMaster and Executor In runtime, every application instance is represented by a single AppMaster and a list of Executors. AppMaster represents the command and controls center of the Application instance. It communicates with user, master, worker, and executor to get the job done. Each executor is a parallel unit for distributed application. Typically AppMaster and Executor will be started as JVM processes on worker nodes. Application Submission Flow When user submits an application to Master, Master will first find an available worker to start the AppMaster. After AppMaster is started, AppMaster will request Master for more resources (worker) to start executors. The Executor now is only an empty container. After the executors are started, the AppMaster will then distribute real computation tasks to the executor and run them in parallel way. To submit an application, a Gearpump client specifies a computation defined within a DAG and submits this to an active master. The SubmitApplication message is sent to the Master who then forwards this to an AppManager. Figure: User Submit Application The AppManager locates an available worker and launches an AppMaster in a sub-process JVM of the worker. The AppMaster will then negotiate with the Master for Resource allocation in order to distribute the DAG as defined within the Application. The allocated workers will then launch Executors (new JVMs). Figure: Launch Executors and Tasks Streaming Topology, Processor, and Task For streaming application type, each application contains a topology, which is a DAG (directed acyclic graph) to describe the data flow. Each node in the DAG is a processor. For example, for word count it contains two processors, Split and Sum. The Split processor splits a line to a list of words, and then the Sum processor summarize the frequency of each word. An application is a DAG of processors. Each processor handles messages. Figure: Processor DAG Streaming Task and Partitioner For streaming application type, Task is the minimum unit of parallelism. In runtime, each Processor is paralleled to a list of tasks, with different tasks running in different executor. You can define Partitioner to denote the data shuffling rule between upstream processor tasks and downstream processor tasks. Figure: Task Data Shuffling","title":"Basic Concepts"},{"location":"introduction/basic-concepts.html#system-timestamp-and-application-timestamp","text":"System timestamp denotes the time of backend cluster system. Application timestamp denotes the time at which message is generated. For example, for IoT edge device, the timestamp at which field sensor device creates a message is type of application timestamp, while the timestamp at which that message get received by the backend is type of system time.","title":"System timestamp and Application timestamp"},{"location":"introduction/basic-concepts.html#master-and-worker","text":"Gearpump follow master slave architecture. Every cluster contains one or more Master node, and several worker nodes. Worker node is responsible to manage local resources on single machine, and Master node is responsible to manage global resources of the whole cluster.","title":"Master, and Worker"},{"location":"introduction/basic-concepts.html#application","text":"Application is what we want to parallel and run on the cluster. There are different application types, for example MapReduce application and streaming application are different application types. Gearpump natively supports Streaming Application types, it also contains several templates to help user to create custom application types, like distributedShell.","title":"Application"},{"location":"introduction/basic-concepts.html#appmaster-and-executor","text":"In runtime, every application instance is represented by a single AppMaster and a list of Executors. AppMaster represents the command and controls center of the Application instance. It communicates with user, master, worker, and executor to get the job done. Each executor is a parallel unit for distributed application. Typically AppMaster and Executor will be started as JVM processes on worker nodes.","title":"AppMaster and Executor"},{"location":"introduction/basic-concepts.html#application-submission-flow","text":"When user submits an application to Master, Master will first find an available worker to start the AppMaster. After AppMaster is started, AppMaster will request Master for more resources (worker) to start executors. The Executor now is only an empty container. After the executors are started, the AppMaster will then distribute real computation tasks to the executor and run them in parallel way. To submit an application, a Gearpump client specifies a computation defined within a DAG and submits this to an active master. The SubmitApplication message is sent to the Master who then forwards this to an AppManager. Figure: User Submit Application The AppManager locates an available worker and launches an AppMaster in a sub-process JVM of the worker. The AppMaster will then negotiate with the Master for Resource allocation in order to distribute the DAG as defined within the Application. The allocated workers will then launch Executors (new JVMs). Figure: Launch Executors and Tasks","title":"Application Submission Flow"},{"location":"introduction/basic-concepts.html#streaming-topology-processor-and-task","text":"For streaming application type, each application contains a topology, which is a DAG (directed acyclic graph) to describe the data flow. Each node in the DAG is a processor. For example, for word count it contains two processors, Split and Sum. The Split processor splits a line to a list of words, and then the Sum processor summarize the frequency of each word. An application is a DAG of processors. Each processor handles messages. Figure: Processor DAG","title":"Streaming Topology, Processor, and Task"},{"location":"introduction/basic-concepts.html#streaming-task-and-partitioner","text":"For streaming application type, Task is the minimum unit of parallelism. In runtime, each Processor is paralleled to a list of tasks, with different tasks running in different executor. You can define Partitioner to denote the data shuffling rule between upstream processor tasks and downstream processor tasks. Figure: Task Data Shuffling","title":"Streaming Task and Partitioner"},{"location":"introduction/commandline.html","text":"The commands can be found at: \"bin\" folder of Gearpump binary. NOTE: on MS Windows platform, please use window shell gear.bat script instead. bash script doesn't work well in cygwin/mingw. Creating an uber-jar If you use Maven you can have a look here whereas SBT users may find this useful. Submit an new application You can use the command gear under the bin directory to submit, query and terminate an application: gear app [-namePrefix <application name prefix>] [-executors <number of executors to launch>] [-conf <custom gearpump config file>] -jar xx.jar MainClass <arg1> <arg2> ... List all running applications To list all running applications: gear info [-conf <custom gearpump config file>] Kill a running application To kill an application: gear kill -appid <application id> [-conf <custom gearpump config file>] Submit a storm application to Gearpump Cluster For example, to submit a storm application jar: storm -verbose -config storm.yaml -jar storm-starter-${STORM_VERSION}.jar storm.starter.ExclamationTopology exclamation Storm Compatibility Guide Start Gearpump Cluster on YARN To start a Gearpump Cluster on YARN, you can: yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip /usr/lib/gearpump/gearpump-2.12-0.9.0.zip should be available on HDFS. Please check YARN Deployment Guide for more information. Start a local cluster Masters and workers will be started in one machine: local Check Deployment Guide for Local Cluster for more information. Start master daemons master -ip <Ip address> -port <port where this master is hooking> Please check Deployment for Standalone mode for more information. Start worker daemons worker Please check Deployment for Standalone mode for more information. Start UI server To start UI server, you can: services [-master <host:port>] The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users.","title":"Client Command Line"},{"location":"introduction/commandline.html#creating-an-uber-jar","text":"If you use Maven you can have a look here whereas SBT users may find this useful.","title":"Creating an uber-jar"},{"location":"introduction/commandline.html#submit-an-new-application","text":"You can use the command gear under the bin directory to submit, query and terminate an application: gear app [-namePrefix <application name prefix>] [-executors <number of executors to launch>] [-conf <custom gearpump config file>] -jar xx.jar MainClass <arg1> <arg2> ...","title":"Submit an new application"},{"location":"introduction/commandline.html#list-all-running-applications","text":"To list all running applications: gear info [-conf <custom gearpump config file>]","title":"List all running applications"},{"location":"introduction/commandline.html#kill-a-running-application","text":"To kill an application: gear kill -appid <application id> [-conf <custom gearpump config file>]","title":"Kill a running application"},{"location":"introduction/commandline.html#submit-a-storm-application-to-gearpump-cluster","text":"For example, to submit a storm application jar: storm -verbose -config storm.yaml -jar storm-starter-${STORM_VERSION}.jar storm.starter.ExclamationTopology exclamation Storm Compatibility Guide","title":"Submit a storm application to Gearpump Cluster"},{"location":"introduction/commandline.html#start-gearpump-cluster-on-yarn","text":"To start a Gearpump Cluster on YARN, you can: yarnclient launch -package /usr/lib/gearpump/gearpump-2.12-0.9.0.zip /usr/lib/gearpump/gearpump-2.12-0.9.0.zip should be available on HDFS. Please check YARN Deployment Guide for more information.","title":"Start Gearpump Cluster on YARN"},{"location":"introduction/commandline.html#start-a-local-cluster","text":"Masters and workers will be started in one machine: local Check Deployment Guide for Local Cluster for more information.","title":"Start a local cluster"},{"location":"introduction/commandline.html#start-master-daemons","text":"master -ip <Ip address> -port <port where this master is hooking> Please check Deployment for Standalone mode for more information.","title":"Start master daemons"},{"location":"introduction/commandline.html#start-worker-daemons","text":"worker Please check Deployment for Standalone mode for more information.","title":"Start worker daemons"},{"location":"introduction/commandline.html#start-ui-server","text":"To start UI server, you can: services [-master <host:port>] The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users.","title":"Start UI server"},{"location":"introduction/features.html","text":"Technical highlights of Gearpump Gearpump is a high performance, flexible, fault-tolerant, and responsive streaming platform with a lot of nice features, its technical highlights include: Actors everywhere The Actor model is a concurrency model proposed by Carl Hewitt at 1973. The Actor model is like a micro-service which is cohesive in the inside and isolated from other outside actors. Actors are the cornerstone of Gearpump, they provide facilities to do message passing, error handling, liveliness monitoring. Gearpump uses Actors everywhere; every entity within the cluster that can be treated as a service. Exactly once Message Processing Exactly once is defined as: the effect of a message will be calculated only once in the persisted state and computation errors in the history will not be propagated to future computations. Topology DAG DSL User can submit to Gearpump a computation DAG, which contains a list of nodes and edges, and each node can be parallelized to a set of tasks. Gearpump will then schedule and distribute different tasks in the DAG to different machines automatically. Each task will be started as an actor, which is long running micro-service. Flow control Gearpump has built-in support for flow control. For all message passing between different tasks, the framework will assure the upstream tasks will not flood the downstream tasks. No inherent end to end latency Gearpump is a message level streaming engine, which means every task in the DAG will process messages immediately upon receiving, and deliver messages to downstream immediately without waiting. Gearpump doesn't do batching when data sourcing. High Performance message passing By implementing smart batching strategies, Gearpump is extremely effective in transferring small messages. In one test of 4 machines, the whole cluster throughput can reach 18 million messages per second, with message size of 100 bytes. High availability, No single point of failure Gearpump has a careful design for high availability. We have considered message loss, worker machine crash, application crash, master crash, brain-split, and have made sure Gearpump recovers when these errors may occur. When there is message loss, the lost message will be replayed; when there is a worker machine crash or application crash, the related computation tasks will be rescheduled on new machines. For master high availability, several master nodes will form a Akka cluster, and CRDTs (conflict free data types) are used to exchange the state, so as long as there is still a quorum, the master will stay functional. When one master node fails, other master nodes in the cluster will take over and state will be recovered. Dynamic Computation DAG Gearpump provides a feature which allows the user to dynamically add, remove, or replace a sub graph at runtime, without the need to restart the whole computation topology. Able to handle out of order messages For a window operation like moving average on a sliding window, it is important to make sure we have received all messages in that time window so that we can get an accurate result, but how do we handle stranglers or late arriving messages? Gearpump solves this problem by tracking the low watermark of timestamp of all messages, so it knows whether we've received all the messages in the time window or not. Customizable platform Different applications have different requirements related to performance metrics, some may want higher throughput, some may require strong eventual data consistency; and different applications have different resource requirements profiles, some may demand high CPU performance, some may require data locality. Gearpump meets these requirements by allowing the user to arbitrate between different performance metrics and define customized resource scheduling strategies. Built-in Dashboard UI Gearpump has a built-in dashboard UI to manage the cluster and visualize the applications. The UI uses REST calls to connect with backend, so it is easy to embed the UI within other dashboards. Data connectors for Kafka and HDFS Gearpump has built-in data connectors for Kafka and HDFS. For the Kafka connector, we support message replay from a specified timestamp.","title":"Technical Highlights"},{"location":"introduction/features.html#technical-highlights-of-gearpump","text":"Gearpump is a high performance, flexible, fault-tolerant, and responsive streaming platform with a lot of nice features, its technical highlights include:","title":"Technical highlights of Gearpump"},{"location":"introduction/features.html#actors-everywhere","text":"The Actor model is a concurrency model proposed by Carl Hewitt at 1973. The Actor model is like a micro-service which is cohesive in the inside and isolated from other outside actors. Actors are the cornerstone of Gearpump, they provide facilities to do message passing, error handling, liveliness monitoring. Gearpump uses Actors everywhere; every entity within the cluster that can be treated as a service.","title":"Actors everywhere"},{"location":"introduction/features.html#exactly-once-message-processing","text":"Exactly once is defined as: the effect of a message will be calculated only once in the persisted state and computation errors in the history will not be propagated to future computations.","title":"Exactly once Message Processing"},{"location":"introduction/features.html#topology-dag-dsl","text":"User can submit to Gearpump a computation DAG, which contains a list of nodes and edges, and each node can be parallelized to a set of tasks. Gearpump will then schedule and distribute different tasks in the DAG to different machines automatically. Each task will be started as an actor, which is long running micro-service.","title":"Topology DAG DSL"},{"location":"introduction/features.html#flow-control","text":"Gearpump has built-in support for flow control. For all message passing between different tasks, the framework will assure the upstream tasks will not flood the downstream tasks.","title":"Flow control"},{"location":"introduction/features.html#no-inherent-end-to-end-latency","text":"Gearpump is a message level streaming engine, which means every task in the DAG will process messages immediately upon receiving, and deliver messages to downstream immediately without waiting. Gearpump doesn't do batching when data sourcing.","title":"No inherent end to end latency"},{"location":"introduction/features.html#high-performance-message-passing","text":"By implementing smart batching strategies, Gearpump is extremely effective in transferring small messages. In one test of 4 machines, the whole cluster throughput can reach 18 million messages per second, with message size of 100 bytes.","title":"High Performance message passing"},{"location":"introduction/features.html#high-availability-no-single-point-of-failure","text":"Gearpump has a careful design for high availability. We have considered message loss, worker machine crash, application crash, master crash, brain-split, and have made sure Gearpump recovers when these errors may occur. When there is message loss, the lost message will be replayed; when there is a worker machine crash or application crash, the related computation tasks will be rescheduled on new machines. For master high availability, several master nodes will form a Akka cluster, and CRDTs (conflict free data types) are used to exchange the state, so as long as there is still a quorum, the master will stay functional. When one master node fails, other master nodes in the cluster will take over and state will be recovered.","title":"High availability, No single point of failure"},{"location":"introduction/features.html#dynamic-computation-dag","text":"Gearpump provides a feature which allows the user to dynamically add, remove, or replace a sub graph at runtime, without the need to restart the whole computation topology.","title":"Dynamic Computation DAG"},{"location":"introduction/features.html#able-to-handle-out-of-order-messages","text":"For a window operation like moving average on a sliding window, it is important to make sure we have received all messages in that time window so that we can get an accurate result, but how do we handle stranglers or late arriving messages? Gearpump solves this problem by tracking the low watermark of timestamp of all messages, so it knows whether we've received all the messages in the time window or not.","title":"Able to handle out of order messages"},{"location":"introduction/features.html#customizable-platform","text":"Different applications have different requirements related to performance metrics, some may want higher throughput, some may require strong eventual data consistency; and different applications have different resource requirements profiles, some may demand high CPU performance, some may require data locality. Gearpump meets these requirements by allowing the user to arbitrate between different performance metrics and define customized resource scheduling strategies.","title":"Customizable platform"},{"location":"introduction/features.html#built-in-dashboard-ui","text":"Gearpump has a built-in dashboard UI to manage the cluster and visualize the applications. The UI uses REST calls to connect with backend, so it is easy to embed the UI within other dashboards.","title":"Built-in Dashboard UI"},{"location":"introduction/features.html#data-connectors-for-kafka-and-hdfs","text":"Gearpump has built-in data connectors for Kafka and HDFS. For the Kafka connector, we support message replay from a specified timestamp.","title":"Data connectors for Kafka and HDFS"},{"location":"introduction/message-delivery.html","text":"What is At Least Once Message Delivery? Messages could be lost on delivery due to network partitions. At Least Once Message Delivery (at least once) means the lost messages are delivered one or more times such that at least one is processed and acknowledged by the whole flow. Gearpump guarantees at least once for any source that is able to replay message from a past timestamp. In Gearpump, each message is tagged with a timestamp, and the system tracks the minimum timestamp of all pending messages (the global minimum clock). On message loss, application will be restarted to the global minimum clock. Since the source is able to replay from the global minimum clock, all pending messages before the restart will be replayed. Gearpump calls that kind of source TimeReplayableSource and already provides a built in KafkaSource . With the KafkaSource to ingest data into Gearpump, users are guaranteed at least once message delivery. What is Exactly Once Message Delivery? At least once delivery doesn't guarantee the correctness of the application result. For instance, for a task keeping the count of received messages, there could be overcount with duplicated messages and the count is lost on task failure. In that case, Exactly Once Message Delivery (exactly once) is required, where state is updated by a message exactly once. This further requires that duplicated messages are filtered out and in-memory states are persisted. Users are guaranteed exactly once in Gearpump if they use both a TimeReplayableSource to ingest data and the Persistent API to manage their in memory states. With the Persistent API, user state is periodically checkpointed by the system to a persistent store (e.g HDFS) along with its checkpointed time. Gearpump tracks the global minimum checkpoint timestamp of all pending states (global minimum checkpoint clock), which is persisted as well. On application restart, the system restores states at the global minimum checkpoint clock and source replays messages from that clock. This ensures that a message updates all states exactly once. Persistent API Persistent API consists of PersistentTask and PersistentState . Here is an example of using them to keep count of incoming messages. class CountProcessor(taskContext: TaskContext, conf: UserConfig) extends PersistentTask[Long](taskContext, conf) { override def persistentState: PersistentState[Long] = { import com.twitter.algebird.Monoid.longMonoid new NonWindowState[Long](new AlgebirdMonoid(longMonoid), new ChillSerializer[Long]) } override def processMessage(state: PersistentState[Long], message: Message): Unit = { state.update(message.timestamp, 1L) } } The CountProcessor creates a customized PersistentState which will be managed by PersistentTask and overrides the processMessage method to define how the state is updated on a new message (each new message counts as 1 , which is added to the existing value) Gearpump has already offered two types of states NonWindowState - state with no time or other boundary WindowState - each state is bounded by a time window They are intended for states that satisfy monoid laws. has binary associative operation, like + has an identity element, like 0 In the above example, we make use of the longMonoid from Twitter's Algebird library which provides a bunch of useful monoids.","title":"Reliable Message Delivery"},{"location":"introduction/message-delivery.html#what-is-at-least-once-message-delivery","text":"Messages could be lost on delivery due to network partitions. At Least Once Message Delivery (at least once) means the lost messages are delivered one or more times such that at least one is processed and acknowledged by the whole flow. Gearpump guarantees at least once for any source that is able to replay message from a past timestamp. In Gearpump, each message is tagged with a timestamp, and the system tracks the minimum timestamp of all pending messages (the global minimum clock). On message loss, application will be restarted to the global minimum clock. Since the source is able to replay from the global minimum clock, all pending messages before the restart will be replayed. Gearpump calls that kind of source TimeReplayableSource and already provides a built in KafkaSource . With the KafkaSource to ingest data into Gearpump, users are guaranteed at least once message delivery.","title":"What is At Least Once Message Delivery?"},{"location":"introduction/message-delivery.html#what-is-exactly-once-message-delivery","text":"At least once delivery doesn't guarantee the correctness of the application result. For instance, for a task keeping the count of received messages, there could be overcount with duplicated messages and the count is lost on task failure. In that case, Exactly Once Message Delivery (exactly once) is required, where state is updated by a message exactly once. This further requires that duplicated messages are filtered out and in-memory states are persisted. Users are guaranteed exactly once in Gearpump if they use both a TimeReplayableSource to ingest data and the Persistent API to manage their in memory states. With the Persistent API, user state is periodically checkpointed by the system to a persistent store (e.g HDFS) along with its checkpointed time. Gearpump tracks the global minimum checkpoint timestamp of all pending states (global minimum checkpoint clock), which is persisted as well. On application restart, the system restores states at the global minimum checkpoint clock and source replays messages from that clock. This ensures that a message updates all states exactly once.","title":"What is Exactly Once Message Delivery?"},{"location":"introduction/message-delivery.html#persistent-api","text":"Persistent API consists of PersistentTask and PersistentState . Here is an example of using them to keep count of incoming messages. class CountProcessor(taskContext: TaskContext, conf: UserConfig) extends PersistentTask[Long](taskContext, conf) { override def persistentState: PersistentState[Long] = { import com.twitter.algebird.Monoid.longMonoid new NonWindowState[Long](new AlgebirdMonoid(longMonoid), new ChillSerializer[Long]) } override def processMessage(state: PersistentState[Long], message: Message): Unit = { state.update(message.timestamp, 1L) } } The CountProcessor creates a customized PersistentState which will be managed by PersistentTask and overrides the processMessage method to define how the state is updated on a new message (each new message counts as 1 , which is added to the existing value) Gearpump has already offered two types of states NonWindowState - state with no time or other boundary WindowState - each state is bounded by a time window They are intended for states that satisfy monoid laws. has binary associative operation, like + has an identity element, like 0 In the above example, we make use of the longMonoid from Twitter's Algebird library which provides a bunch of useful monoids.","title":"Persistent API"},{"location":"introduction/performance-report.html","text":"Performance Evaluation To illustrate the performance of Gearpump, we mainly focused on two aspects, throughput and latency, using a micro benchmark called SOL (an example in the Gearpump package) whose topology is quite simple. SOLStreamProducer delivers messages to SOLStreamProcessor constantly and SOLStreamProcessor does nothing. We set up a 4-nodes cluster with 10GbE network and each node's hardware is briefly shown as follows: Processor: 32 core Intel(R) Xeon(R) CPU E5-2690 2.90GHz Memory: 64GB Throughput We tried to explore the upper bound of the throughput, after launching 48 SOLStreamProducer and 48 SOLStreamProcessor the Figure below shows that the whole throughput of the cluster can reach about 18 million messages/second(100 bytes per message) Latency When we transfer message at the max throughput above, the average latency between two tasks is 8ms. Fault Recovery time When the corruption is detected, for example the Executor is down, Gearpump will reallocate the resource and restart the application. It takes about 10 seconds to recover the application. How to setup the benchmark environment? Prepare the env 1). Set up a 4-nodes Gearpump cluster with 10GbE network which have 4 Workers on each node. In our test environment, each node has 64GB memory and Intel(R) Xeon(R) 32-core processor E5-2690 2.90GHz. Make sure the metrics is enabled in Gearpump. 2). Submit a SOL application with 48 StreamProducers and 48 StreamProcessors: bin/gear app -jar ./examples/sol-2.12-0.9.0-assembly.jar -streamProducer 48 -streamProcessor 48 3). Launch Gearpump's dashboard and browser http://$HOST:8090/, switch to the Applications tab and you can see the detail information of your application. The HOST should be the node runs dashboard.","title":"Performance"},{"location":"introduction/performance-report.html#performance-evaluation","text":"To illustrate the performance of Gearpump, we mainly focused on two aspects, throughput and latency, using a micro benchmark called SOL (an example in the Gearpump package) whose topology is quite simple. SOLStreamProducer delivers messages to SOLStreamProcessor constantly and SOLStreamProcessor does nothing. We set up a 4-nodes cluster with 10GbE network and each node's hardware is briefly shown as follows: Processor: 32 core Intel(R) Xeon(R) CPU E5-2690 2.90GHz Memory: 64GB","title":"Performance Evaluation"},{"location":"introduction/performance-report.html#throughput","text":"We tried to explore the upper bound of the throughput, after launching 48 SOLStreamProducer and 48 SOLStreamProcessor the Figure below shows that the whole throughput of the cluster can reach about 18 million messages/second(100 bytes per message)","title":"Throughput"},{"location":"introduction/performance-report.html#latency","text":"When we transfer message at the max throughput above, the average latency between two tasks is 8ms.","title":"Latency"},{"location":"introduction/performance-report.html#fault-recovery-time","text":"When the corruption is detected, for example the Executor is down, Gearpump will reallocate the resource and restart the application. It takes about 10 seconds to recover the application.","title":"Fault Recovery time"},{"location":"introduction/performance-report.html#how-to-setup-the-benchmark-environment","text":"","title":"How to setup the benchmark environment?"},{"location":"introduction/performance-report.html#prepare-the-env","text":"1). Set up a 4-nodes Gearpump cluster with 10GbE network which have 4 Workers on each node. In our test environment, each node has 64GB memory and Intel(R) Xeon(R) 32-core processor E5-2690 2.90GHz. Make sure the metrics is enabled in Gearpump. 2). Submit a SOL application with 48 StreamProducers and 48 StreamProcessors: bin/gear app -jar ./examples/sol-2.12-0.9.0-assembly.jar -streamProducer 48 -streamProcessor 48 3). Launch Gearpump's dashboard and browser http://$HOST:8090/, switch to the Applications tab and you can see the detail information of your application. The HOST should be the node runs dashboard.","title":"Prepare the env"},{"location":"introduction/quick-start.html","text":"This quick start will walk you through executing your first Gearpump pipeline to run WordCount written in Stream DSL. Set up development environment Download and install Java Development Kit(JDK) 1.8. Verify that JAVA_HOME is set and points to your JDK installation. Download and install sbt by following sbt's installation guide for your specific operating system. Run WordCount Run WordCount example with sbt sbt \"project gearpump-examples-wordcount\" run Select the third main class in the sbt console Multiple main classes detected, select one to run: [1] io.gearpump.streaming.examples.wordcount.WordCount [2] io.gearpump.streaming.examples.wordcount.dsl.WindowedWordCount [3] io.gearpump.streaming.examples.wordcount.dsl.WordCount Enter number: 3 If everything goes fine, the following output is expected (is,1)(bingo!!,2)(a,1)(good,1)(This,1)(start,,1)","title":"Quick Start"},{"location":"introduction/quick-start.html#set-up-development-environment","text":"Download and install Java Development Kit(JDK) 1.8. Verify that JAVA_HOME is set and points to your JDK installation. Download and install sbt by following sbt's installation guide for your specific operating system.","title":"Set up development environment"},{"location":"introduction/quick-start.html#run-wordcount","text":"Run WordCount example with sbt sbt \"project gearpump-examples-wordcount\" run Select the third main class in the sbt console Multiple main classes detected, select one to run: [1] io.gearpump.streaming.examples.wordcount.WordCount [2] io.gearpump.streaming.examples.wordcount.dsl.WindowedWordCount [3] io.gearpump.streaming.examples.wordcount.dsl.WordCount Enter number: 3 If everything goes fine, the following output is expected (is,1)(bingo!!,2)(a,1)(good,1)(This,1)(start,,1)","title":"Run WordCount"},{"location":"introduction/submit-your-1st-application.html","text":"Before you can submit and run your first Gearpump application, you will need a running Gearpump service. There are multiple ways to run Gearpump Local mode , Standalone mode , YARN mode or Docker mode . The easiest way is to run Gearpump in Local mode . Any Linux, MacOSX or Windows desktop can be used with zero configuration. In the example below, we assume your are running in Local mode . If you running Gearpump in one of the other modes, you will need to configure the Gearpump client to connect to the Gearpump service by setting the gear.conf configuration path in classpath. Within this file, you will need to change the parameter gearpump.cluster.masters to the correct Gearpump master(s). See Configuration for details. Steps to submit your first Application Step 1: Submit application After the cluster is started, you can submit an example wordcount application to the cluster Open another shell, ### To run WordCount example bin/gear app -jar examples/wordcount-2.12-0.9.0-assembly.jar io.gearpump.streaming.examples.wordcount.WordCount Step 2: Congratulations, you've submitted your first application. To view the application status and metrics, start the Web UI services, and browse to http://127.0.0.1:8090 to check the status. The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users. NOTE: the UI port setting can be defined in configuration, please check section Configuration . Other Application Examples Besides wordcount, there are several other example applications. Please check the source tree examples/ for detail information.","title":"Submit Your 1st Application"},{"location":"introduction/submit-your-1st-application.html#steps-to-submit-your-first-application","text":"","title":"Steps to submit your first Application"},{"location":"introduction/submit-your-1st-application.html#step-1-submit-application","text":"After the cluster is started, you can submit an example wordcount application to the cluster Open another shell, ### To run WordCount example bin/gear app -jar examples/wordcount-2.12-0.9.0-assembly.jar io.gearpump.streaming.examples.wordcount.WordCount","title":"Step 1: Submit application"},{"location":"introduction/submit-your-1st-application.html#step-2-congratulations-youve-submitted-your-first-application","text":"To view the application status and metrics, start the Web UI services, and browse to http://127.0.0.1:8090 to check the status. The default username and password is \"admin:admin\", you can check UI Authentication to find how to manage users. NOTE: the UI port setting can be defined in configuration, please check section Configuration .","title":"Step 2: Congratulations, you've submitted your first application."},{"location":"introduction/submit-your-1st-application.html#other-application-examples","text":"Besides wordcount, there are several other example applications. Please check the source tree examples/ for detail information.","title":"Other Application Examples"}]}